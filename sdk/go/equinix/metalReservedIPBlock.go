// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package equinix

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to create and manage blocks of reserved IP addresses in a project.
//
// When a user provisions first device in a facility, Equinix Metal API automatically allocates IPv6/56 and private IPv4/25 blocks.
// The new device then gets IPv6 and private IPv4 addresses from those block. It also gets a public IPv4/31 address.
// Every new device in the project and facility will automatically get IPv6 and private IPv4 addresses from these pre-allocated blocks.
// The IPv6 and private IPv4 blocks can't be created, only imported. With this resource, it's possible to create either public IPv4 blocks or global IPv4 blocks.
//
// Public blocks are allocated in a facility. Addresses from public blocks can only be assigned to devices in the facility. Public blocks can have mask from /24 (256 addresses) to /32 (1 address). If you create public block with this resource, you must fill the facility argument.
//
// Addresses from global blocks can be assigned in any facility. Global blocks can have mask from /30 (4 addresses), to /32 (1 address). If you create global block with this resource, you must specify type = "globalIpv4" and you must omit the facility argument.
//
// Once IP block is allocated or imported, an address from it can be assigned to device with the `MetalIPAttachment` resource.
//
// > VRF features are not generally available. The interfaces related to VRF resources may change ahead of general availability.
//
// ## Example Usage
//
// Allocate reserved IP blocks:
//
// ```go
// package main
//
// import (
// 	"github.com/cuemby/pulumi-equinix/sdk/go/equinix"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := equinix.NewMetalReservedIPBlock(ctx, "twoElasticAddresses", &equinix.MetalReservedIPBlockArgs{
// 			ProjectId: pulumi.Any(local.Project_id),
// 			Facility:  pulumi.String("sv15"),
// 			Quantity:  pulumi.Int(2),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = equinix.NewMetalReservedIPBlock(ctx, "testMetalReservedIPBlock", &equinix.MetalReservedIPBlockArgs{
// 			ProjectId: pulumi.Any(local.Project_id),
// 			Type:      pulumi.String("public_ipv4"),
// 			Metro:     pulumi.String("sv"),
// 			Quantity:  pulumi.Int(1),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = equinix.NewMetalReservedIPBlock(ctx, "testIndex/metalReservedIPBlockMetalReservedIPBlock", &equinix.MetalReservedIPBlockArgs{
// 			ProjectId: pulumi.Any(local.Project_id),
// 			Type:      pulumi.String("global_ipv4"),
// 			Quantity:  pulumi.Int(1),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// Allocate a block and run a device with public IPv4 from the block
//
// ```go
// package main
//
// import (
// 	"github.com/cuemby/pulumi-equinix/sdk/go/equinix"
// 	"github.com/pulumi/pulumi-equinix/sdk/go/equinix"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		example, err := equinix.NewMetalReservedIPBlock(ctx, "example", &equinix.MetalReservedIPBlockArgs{
// 			ProjectId: pulumi.Any(local.Project_id),
// 			Facility:  pulumi.String("sv15"),
// 			Quantity:  pulumi.Int(2),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = equinix.NewMetalDevice(ctx, "nodes", &equinix.MetalDeviceArgs{
// 			ProjectId: pulumi.Any(local.Project_id),
// 			Facilities: pulumi.StringArray{
// 				pulumi.String("sv15"),
// 			},
// 			Plan:            pulumi.String("c3.small.x86"),
// 			OperatingSystem: pulumi.String("ubuntu_20_04"),
// 			Hostname:        pulumi.String("test"),
// 			BillingCycle:    pulumi.String("hourly"),
// 			IpAddresses: MetalDeviceIpAddressArray{
// 				&MetalDeviceIpAddressArgs{
// 					Type: pulumi.String("public_ipv4"),
// 					Cidr: pulumi.Int(31),
// 					ReservationIds: pulumi.StringArray{
// 						example.ID(),
// 					},
// 				},
// 				&MetalDeviceIpAddressArgs{
// 					Type: pulumi.String("private_ipv4"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// This resource can be imported using an existing IP reservation ID
//
// ```sh
//  $ pulumi import equinix:index/metalReservedIPBlock:MetalReservedIPBlock equinix_metal_reserved_ip_block {existing_ip_reservation_id}
// ```
type MetalReservedIPBlock struct {
	pulumi.CustomResourceState

	Address pulumi.StringOutput `pulumi:"address"`
	// Address family as integer. One of `4` or `6`.
	AddressFamily pulumi.IntOutput `pulumi:"addressFamily"`
	// Only valid as an argument and required when `type` is `vrf`. The size of the network to reserve from an existing VRF ip_range. `cidr` can only be specified with `vrfId`. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
	Cidr pulumi.IntOutput `pulumi:"cidr"`
	// Address and mask in CIDR notation, e.g. `147.229.15.30/31`.
	CidrNotation pulumi.StringOutput `pulumi:"cidrNotation"`
	// Custom Data is an arbitrary object (submitted in Terraform as serialized JSON) to assign to the IP Reservation. This may
	// be helpful for self-managed IPAM. The object must be valid JSON.
	CustomData pulumi.StringPtrOutput `pulumi:"customData"`
	// Arbitrary description.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Facility where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `metro`.
	Facility pulumi.StringPtrOutput `pulumi:"facility"`
	Gateway  pulumi.StringOutput    `pulumi:"gateway"`
	// Boolean flag whether addresses from a block are global (i.e. can be assigned in any
	// facility).
	Global     pulumi.BoolOutput `pulumi:"global"`
	Manageable pulumi.BoolOutput `pulumi:"manageable"`
	Management pulumi.BoolOutput `pulumi:"management"`
	// Metro where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `facility`.
	Metro pulumi.StringPtrOutput `pulumi:"metro"`
	// Mask in decimal notation, e.g. `255.255.255.0`.
	Netmask pulumi.StringOutput `pulumi:"netmask"`
	// Only valid as an argument and required when `type` is `vrf`. An unreserved network address from an existing `ipRange` in the specified VRF.
	Network pulumi.StringOutput `pulumi:"network"`
	// The metal project ID where to allocate the address block.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Boolean flag whether addresses from a block are public.
	Public pulumi.BoolOutput `pulumi:"public"`
	// The number of allocated `/32` addresses, a power of 2. Required when `type` is not `vrf`.
	Quantity pulumi.IntOutput `pulumi:"quantity"`
	// String list of tags.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// One of `globalIpv4`, `publicIpv4`, or `vrf`. Defaults to `publicIpv4` for backward
	// compatibility.
	Type pulumi.StringPtrOutput `pulumi:"type"`
	// Only valid and required when `type` is `vrf`. VRF ID for type=vrf reservations.
	VrfId pulumi.StringPtrOutput `pulumi:"vrfId"`
	// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
	WaitForState pulumi.StringPtrOutput `pulumi:"waitForState"`
}

// NewMetalReservedIPBlock registers a new resource with the given unique name, arguments, and options.
func NewMetalReservedIPBlock(ctx *pulumi.Context,
	name string, args *MetalReservedIPBlockArgs, opts ...pulumi.ResourceOption) (*MetalReservedIPBlock, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource MetalReservedIPBlock
	err := ctx.RegisterResource("equinix:index/metalReservedIPBlock:MetalReservedIPBlock", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMetalReservedIPBlock gets an existing MetalReservedIPBlock resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMetalReservedIPBlock(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MetalReservedIPBlockState, opts ...pulumi.ResourceOption) (*MetalReservedIPBlock, error) {
	var resource MetalReservedIPBlock
	err := ctx.ReadResource("equinix:index/metalReservedIPBlock:MetalReservedIPBlock", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MetalReservedIPBlock resources.
type metalReservedIPBlockState struct {
	Address *string `pulumi:"address"`
	// Address family as integer. One of `4` or `6`.
	AddressFamily *int `pulumi:"addressFamily"`
	// Only valid as an argument and required when `type` is `vrf`. The size of the network to reserve from an existing VRF ip_range. `cidr` can only be specified with `vrfId`. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
	Cidr *int `pulumi:"cidr"`
	// Address and mask in CIDR notation, e.g. `147.229.15.30/31`.
	CidrNotation *string `pulumi:"cidrNotation"`
	// Custom Data is an arbitrary object (submitted in Terraform as serialized JSON) to assign to the IP Reservation. This may
	// be helpful for self-managed IPAM. The object must be valid JSON.
	CustomData *string `pulumi:"customData"`
	// Arbitrary description.
	Description *string `pulumi:"description"`
	// Facility where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `metro`.
	Facility *string `pulumi:"facility"`
	Gateway  *string `pulumi:"gateway"`
	// Boolean flag whether addresses from a block are global (i.e. can be assigned in any
	// facility).
	Global     *bool `pulumi:"global"`
	Manageable *bool `pulumi:"manageable"`
	Management *bool `pulumi:"management"`
	// Metro where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `facility`.
	Metro *string `pulumi:"metro"`
	// Mask in decimal notation, e.g. `255.255.255.0`.
	Netmask *string `pulumi:"netmask"`
	// Only valid as an argument and required when `type` is `vrf`. An unreserved network address from an existing `ipRange` in the specified VRF.
	Network *string `pulumi:"network"`
	// The metal project ID where to allocate the address block.
	ProjectId *string `pulumi:"projectId"`
	// Boolean flag whether addresses from a block are public.
	Public *bool `pulumi:"public"`
	// The number of allocated `/32` addresses, a power of 2. Required when `type` is not `vrf`.
	Quantity *int `pulumi:"quantity"`
	// String list of tags.
	Tags []string `pulumi:"tags"`
	// One of `globalIpv4`, `publicIpv4`, or `vrf`. Defaults to `publicIpv4` for backward
	// compatibility.
	Type *string `pulumi:"type"`
	// Only valid and required when `type` is `vrf`. VRF ID for type=vrf reservations.
	VrfId *string `pulumi:"vrfId"`
	// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
	WaitForState *string `pulumi:"waitForState"`
}

type MetalReservedIPBlockState struct {
	Address pulumi.StringPtrInput
	// Address family as integer. One of `4` or `6`.
	AddressFamily pulumi.IntPtrInput
	// Only valid as an argument and required when `type` is `vrf`. The size of the network to reserve from an existing VRF ip_range. `cidr` can only be specified with `vrfId`. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
	Cidr pulumi.IntPtrInput
	// Address and mask in CIDR notation, e.g. `147.229.15.30/31`.
	CidrNotation pulumi.StringPtrInput
	// Custom Data is an arbitrary object (submitted in Terraform as serialized JSON) to assign to the IP Reservation. This may
	// be helpful for self-managed IPAM. The object must be valid JSON.
	CustomData pulumi.StringPtrInput
	// Arbitrary description.
	Description pulumi.StringPtrInput
	// Facility where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `metro`.
	Facility pulumi.StringPtrInput
	Gateway  pulumi.StringPtrInput
	// Boolean flag whether addresses from a block are global (i.e. can be assigned in any
	// facility).
	Global     pulumi.BoolPtrInput
	Manageable pulumi.BoolPtrInput
	Management pulumi.BoolPtrInput
	// Metro where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `facility`.
	Metro pulumi.StringPtrInput
	// Mask in decimal notation, e.g. `255.255.255.0`.
	Netmask pulumi.StringPtrInput
	// Only valid as an argument and required when `type` is `vrf`. An unreserved network address from an existing `ipRange` in the specified VRF.
	Network pulumi.StringPtrInput
	// The metal project ID where to allocate the address block.
	ProjectId pulumi.StringPtrInput
	// Boolean flag whether addresses from a block are public.
	Public pulumi.BoolPtrInput
	// The number of allocated `/32` addresses, a power of 2. Required when `type` is not `vrf`.
	Quantity pulumi.IntPtrInput
	// String list of tags.
	Tags pulumi.StringArrayInput
	// One of `globalIpv4`, `publicIpv4`, or `vrf`. Defaults to `publicIpv4` for backward
	// compatibility.
	Type pulumi.StringPtrInput
	// Only valid and required when `type` is `vrf`. VRF ID for type=vrf reservations.
	VrfId pulumi.StringPtrInput
	// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
	WaitForState pulumi.StringPtrInput
}

func (MetalReservedIPBlockState) ElementType() reflect.Type {
	return reflect.TypeOf((*metalReservedIPBlockState)(nil)).Elem()
}

type metalReservedIPBlockArgs struct {
	// Only valid as an argument and required when `type` is `vrf`. The size of the network to reserve from an existing VRF ip_range. `cidr` can only be specified with `vrfId`. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
	Cidr *int `pulumi:"cidr"`
	// Custom Data is an arbitrary object (submitted in Terraform as serialized JSON) to assign to the IP Reservation. This may
	// be helpful for self-managed IPAM. The object must be valid JSON.
	CustomData *string `pulumi:"customData"`
	// Arbitrary description.
	Description *string `pulumi:"description"`
	// Facility where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `metro`.
	Facility *string `pulumi:"facility"`
	// Metro where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `facility`.
	Metro *string `pulumi:"metro"`
	// Only valid as an argument and required when `type` is `vrf`. An unreserved network address from an existing `ipRange` in the specified VRF.
	Network *string `pulumi:"network"`
	// The metal project ID where to allocate the address block.
	ProjectId string `pulumi:"projectId"`
	// The number of allocated `/32` addresses, a power of 2. Required when `type` is not `vrf`.
	Quantity *int `pulumi:"quantity"`
	// String list of tags.
	Tags []string `pulumi:"tags"`
	// One of `globalIpv4`, `publicIpv4`, or `vrf`. Defaults to `publicIpv4` for backward
	// compatibility.
	Type *string `pulumi:"type"`
	// Only valid and required when `type` is `vrf`. VRF ID for type=vrf reservations.
	VrfId *string `pulumi:"vrfId"`
	// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
	WaitForState *string `pulumi:"waitForState"`
}

// The set of arguments for constructing a MetalReservedIPBlock resource.
type MetalReservedIPBlockArgs struct {
	// Only valid as an argument and required when `type` is `vrf`. The size of the network to reserve from an existing VRF ip_range. `cidr` can only be specified with `vrfId`. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
	Cidr pulumi.IntPtrInput
	// Custom Data is an arbitrary object (submitted in Terraform as serialized JSON) to assign to the IP Reservation. This may
	// be helpful for self-managed IPAM. The object must be valid JSON.
	CustomData pulumi.StringPtrInput
	// Arbitrary description.
	Description pulumi.StringPtrInput
	// Facility where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `metro`.
	Facility pulumi.StringPtrInput
	// Metro where to allocate the public IP address block, makes sense only
	// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `facility`.
	Metro pulumi.StringPtrInput
	// Only valid as an argument and required when `type` is `vrf`. An unreserved network address from an existing `ipRange` in the specified VRF.
	Network pulumi.StringPtrInput
	// The metal project ID where to allocate the address block.
	ProjectId pulumi.StringInput
	// The number of allocated `/32` addresses, a power of 2. Required when `type` is not `vrf`.
	Quantity pulumi.IntPtrInput
	// String list of tags.
	Tags pulumi.StringArrayInput
	// One of `globalIpv4`, `publicIpv4`, or `vrf`. Defaults to `publicIpv4` for backward
	// compatibility.
	Type pulumi.StringPtrInput
	// Only valid and required when `type` is `vrf`. VRF ID for type=vrf reservations.
	VrfId pulumi.StringPtrInput
	// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
	WaitForState pulumi.StringPtrInput
}

func (MetalReservedIPBlockArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metalReservedIPBlockArgs)(nil)).Elem()
}

type MetalReservedIPBlockInput interface {
	pulumi.Input

	ToMetalReservedIPBlockOutput() MetalReservedIPBlockOutput
	ToMetalReservedIPBlockOutputWithContext(ctx context.Context) MetalReservedIPBlockOutput
}

func (*MetalReservedIPBlock) ElementType() reflect.Type {
	return reflect.TypeOf((**MetalReservedIPBlock)(nil)).Elem()
}

func (i *MetalReservedIPBlock) ToMetalReservedIPBlockOutput() MetalReservedIPBlockOutput {
	return i.ToMetalReservedIPBlockOutputWithContext(context.Background())
}

func (i *MetalReservedIPBlock) ToMetalReservedIPBlockOutputWithContext(ctx context.Context) MetalReservedIPBlockOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalReservedIPBlockOutput)
}

// MetalReservedIPBlockArrayInput is an input type that accepts MetalReservedIPBlockArray and MetalReservedIPBlockArrayOutput values.
// You can construct a concrete instance of `MetalReservedIPBlockArrayInput` via:
//
//          MetalReservedIPBlockArray{ MetalReservedIPBlockArgs{...} }
type MetalReservedIPBlockArrayInput interface {
	pulumi.Input

	ToMetalReservedIPBlockArrayOutput() MetalReservedIPBlockArrayOutput
	ToMetalReservedIPBlockArrayOutputWithContext(context.Context) MetalReservedIPBlockArrayOutput
}

type MetalReservedIPBlockArray []MetalReservedIPBlockInput

func (MetalReservedIPBlockArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetalReservedIPBlock)(nil)).Elem()
}

func (i MetalReservedIPBlockArray) ToMetalReservedIPBlockArrayOutput() MetalReservedIPBlockArrayOutput {
	return i.ToMetalReservedIPBlockArrayOutputWithContext(context.Background())
}

func (i MetalReservedIPBlockArray) ToMetalReservedIPBlockArrayOutputWithContext(ctx context.Context) MetalReservedIPBlockArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalReservedIPBlockArrayOutput)
}

// MetalReservedIPBlockMapInput is an input type that accepts MetalReservedIPBlockMap and MetalReservedIPBlockMapOutput values.
// You can construct a concrete instance of `MetalReservedIPBlockMapInput` via:
//
//          MetalReservedIPBlockMap{ "key": MetalReservedIPBlockArgs{...} }
type MetalReservedIPBlockMapInput interface {
	pulumi.Input

	ToMetalReservedIPBlockMapOutput() MetalReservedIPBlockMapOutput
	ToMetalReservedIPBlockMapOutputWithContext(context.Context) MetalReservedIPBlockMapOutput
}

type MetalReservedIPBlockMap map[string]MetalReservedIPBlockInput

func (MetalReservedIPBlockMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetalReservedIPBlock)(nil)).Elem()
}

func (i MetalReservedIPBlockMap) ToMetalReservedIPBlockMapOutput() MetalReservedIPBlockMapOutput {
	return i.ToMetalReservedIPBlockMapOutputWithContext(context.Background())
}

func (i MetalReservedIPBlockMap) ToMetalReservedIPBlockMapOutputWithContext(ctx context.Context) MetalReservedIPBlockMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalReservedIPBlockMapOutput)
}

type MetalReservedIPBlockOutput struct{ *pulumi.OutputState }

func (MetalReservedIPBlockOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetalReservedIPBlock)(nil)).Elem()
}

func (o MetalReservedIPBlockOutput) ToMetalReservedIPBlockOutput() MetalReservedIPBlockOutput {
	return o
}

func (o MetalReservedIPBlockOutput) ToMetalReservedIPBlockOutputWithContext(ctx context.Context) MetalReservedIPBlockOutput {
	return o
}

func (o MetalReservedIPBlockOutput) Address() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringOutput { return v.Address }).(pulumi.StringOutput)
}

// Address family as integer. One of `4` or `6`.
func (o MetalReservedIPBlockOutput) AddressFamily() pulumi.IntOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.IntOutput { return v.AddressFamily }).(pulumi.IntOutput)
}

// Only valid as an argument and required when `type` is `vrf`. The size of the network to reserve from an existing VRF ip_range. `cidr` can only be specified with `vrfId`. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
func (o MetalReservedIPBlockOutput) Cidr() pulumi.IntOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.IntOutput { return v.Cidr }).(pulumi.IntOutput)
}

// Address and mask in CIDR notation, e.g. `147.229.15.30/31`.
func (o MetalReservedIPBlockOutput) CidrNotation() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringOutput { return v.CidrNotation }).(pulumi.StringOutput)
}

// Custom Data is an arbitrary object (submitted in Terraform as serialized JSON) to assign to the IP Reservation. This may
// be helpful for self-managed IPAM. The object must be valid JSON.
func (o MetalReservedIPBlockOutput) CustomData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringPtrOutput { return v.CustomData }).(pulumi.StringPtrOutput)
}

// Arbitrary description.
func (o MetalReservedIPBlockOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Facility where to allocate the public IP address block, makes sense only
// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `metro`.
func (o MetalReservedIPBlockOutput) Facility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringPtrOutput { return v.Facility }).(pulumi.StringPtrOutput)
}

func (o MetalReservedIPBlockOutput) Gateway() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringOutput { return v.Gateway }).(pulumi.StringOutput)
}

// Boolean flag whether addresses from a block are global (i.e. can be assigned in any
// facility).
func (o MetalReservedIPBlockOutput) Global() pulumi.BoolOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.BoolOutput { return v.Global }).(pulumi.BoolOutput)
}

func (o MetalReservedIPBlockOutput) Manageable() pulumi.BoolOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.BoolOutput { return v.Manageable }).(pulumi.BoolOutput)
}

func (o MetalReservedIPBlockOutput) Management() pulumi.BoolOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.BoolOutput { return v.Management }).(pulumi.BoolOutput)
}

// Metro where to allocate the public IP address block, makes sense only
// if type is `publicIpv4` and must be empty if type is `globalIpv4`. Conflicts with `facility`.
func (o MetalReservedIPBlockOutput) Metro() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringPtrOutput { return v.Metro }).(pulumi.StringPtrOutput)
}

// Mask in decimal notation, e.g. `255.255.255.0`.
func (o MetalReservedIPBlockOutput) Netmask() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringOutput { return v.Netmask }).(pulumi.StringOutput)
}

// Only valid as an argument and required when `type` is `vrf`. An unreserved network address from an existing `ipRange` in the specified VRF.
func (o MetalReservedIPBlockOutput) Network() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringOutput { return v.Network }).(pulumi.StringOutput)
}

// The metal project ID where to allocate the address block.
func (o MetalReservedIPBlockOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Boolean flag whether addresses from a block are public.
func (o MetalReservedIPBlockOutput) Public() pulumi.BoolOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.BoolOutput { return v.Public }).(pulumi.BoolOutput)
}

// The number of allocated `/32` addresses, a power of 2. Required when `type` is not `vrf`.
func (o MetalReservedIPBlockOutput) Quantity() pulumi.IntOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.IntOutput { return v.Quantity }).(pulumi.IntOutput)
}

// String list of tags.
func (o MetalReservedIPBlockOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// One of `globalIpv4`, `publicIpv4`, or `vrf`. Defaults to `publicIpv4` for backward
// compatibility.
func (o MetalReservedIPBlockOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringPtrOutput { return v.Type }).(pulumi.StringPtrOutput)
}

// Only valid and required when `type` is `vrf`. VRF ID for type=vrf reservations.
func (o MetalReservedIPBlockOutput) VrfId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringPtrOutput { return v.VrfId }).(pulumi.StringPtrOutput)
}

// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
func (o MetalReservedIPBlockOutput) WaitForState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalReservedIPBlock) pulumi.StringPtrOutput { return v.WaitForState }).(pulumi.StringPtrOutput)
}

type MetalReservedIPBlockArrayOutput struct{ *pulumi.OutputState }

func (MetalReservedIPBlockArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetalReservedIPBlock)(nil)).Elem()
}

func (o MetalReservedIPBlockArrayOutput) ToMetalReservedIPBlockArrayOutput() MetalReservedIPBlockArrayOutput {
	return o
}

func (o MetalReservedIPBlockArrayOutput) ToMetalReservedIPBlockArrayOutputWithContext(ctx context.Context) MetalReservedIPBlockArrayOutput {
	return o
}

func (o MetalReservedIPBlockArrayOutput) Index(i pulumi.IntInput) MetalReservedIPBlockOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MetalReservedIPBlock {
		return vs[0].([]*MetalReservedIPBlock)[vs[1].(int)]
	}).(MetalReservedIPBlockOutput)
}

type MetalReservedIPBlockMapOutput struct{ *pulumi.OutputState }

func (MetalReservedIPBlockMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetalReservedIPBlock)(nil)).Elem()
}

func (o MetalReservedIPBlockMapOutput) ToMetalReservedIPBlockMapOutput() MetalReservedIPBlockMapOutput {
	return o
}

func (o MetalReservedIPBlockMapOutput) ToMetalReservedIPBlockMapOutputWithContext(ctx context.Context) MetalReservedIPBlockMapOutput {
	return o
}

func (o MetalReservedIPBlockMapOutput) MapIndex(k pulumi.StringInput) MetalReservedIPBlockOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MetalReservedIPBlock {
		return vs[0].(map[string]*MetalReservedIPBlock)[vs[1].(string)]
	}).(MetalReservedIPBlockOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetalReservedIPBlockInput)(nil)).Elem(), &MetalReservedIPBlock{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetalReservedIPBlockArrayInput)(nil)).Elem(), MetalReservedIPBlockArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetalReservedIPBlockMapInput)(nil)).Elem(), MetalReservedIPBlockMap{})
	pulumi.RegisterOutputType(MetalReservedIPBlockOutput{})
	pulumi.RegisterOutputType(MetalReservedIPBlockArrayOutput{})
	pulumi.RegisterOutputType(MetalReservedIPBlockMapOutput{})
}
