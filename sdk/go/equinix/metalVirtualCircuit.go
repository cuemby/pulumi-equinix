// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package equinix

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to associate VLAN with a Dedicated Port from
// [Equinix Fabric - software-defined interconnections](https://metal.equinix.com/developers/docs/networking/fabric/#associating-a-vlan-with-a-dedicated-port).
//
// > VRF features are not generally available. The interfaces related to VRF resources may change ahead of general availability.
//
// ## Example Usage
//
// Pick an existing Project and Connection, create a VLAN and use `MetalVirtualCircuit`
// to associate it with a Primary Port of the Connection.
//
// ```go
// package main
//
// import (
// 	"github.com/cuemby/pulumi-equinix/sdk/go/equinix"
// 	"github.com/pulumi/pulumi-equinix/sdk/go/equinix"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		projectId := "52000fb2-ee46-4673-93a8-de2c2bdba33c"
// 		connId := "73f12f29-3e19-43a0-8e90-ae81580db1e0"
// 		testGetMetalConnection, err := equinix.GetMetalConnection(ctx, &GetMetalConnectionArgs{
// 			ConnectionId: connId,
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		testMetalVlan, err := equinix.NewMetalVlan(ctx, "testMetalVlan", &equinix.MetalVlanArgs{
// 			ProjectId: pulumi.String(projectId),
// 			Metro:     pulumi.String(testGetMetalConnection.Metro),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = equinix.NewMetalVirtualCircuit(ctx, "testMetalVirtualCircuit", &equinix.MetalVirtualCircuitArgs{
// 			ConnectionId: pulumi.String(connId),
// 			ProjectId:    pulumi.String(projectId),
// 			PortId:       pulumi.String(testGetMetalConnection.Ports[0].Id),
// 			VlanId:       testMetalVlan.ID(),
// 			NniVlan:      pulumi.Int(1056),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// This resource can be imported using an existing Virtual Circuit ID
//
// ```sh
//  $ pulumi import equinix:index/metalVirtualCircuit:MetalVirtualCircuit equinix_metal_virtual_circuit {existing_id}
// ```
type MetalVirtualCircuit struct {
	pulumi.CustomResourceState

	// UUID of Connection where the VC is scoped to.
	ConnectionId pulumi.StringOutput `pulumi:"connectionId"`
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp pulumi.StringPtrOutput `pulumi:"customerIp"`
	// Description for the Virtual Circuit resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The password that can be set for the VRF BGP peer
	Md5 pulumi.StringPtrOutput `pulumi:"md5"`
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp pulumi.StringPtrOutput `pulumi:"metalIp"`
	// Name of the Virtual Circuit resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// Equinix Metal network-to-network VLAN ID.
	NniVlan pulumi.IntPtrOutput `pulumi:"nniVlan"`
	// NNI VLAN parameters, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	NniVnid pulumi.IntOutput `pulumi:"nniVnid"`
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn pulumi.IntPtrOutput `pulumi:"peerAsn"`
	// UUID of the Connection Port where the VC is scoped to.
	PortId pulumi.StringOutput `pulumi:"portId"`
	// UUID of the Project where the VC is scoped to.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Speed of the Virtual Circuit resource.
	Speed pulumi.StringOutput `pulumi:"speed"`
	// Status of the virtal circuit.
	Status pulumi.StringOutput `pulumi:"status"`
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet pulumi.StringPtrOutput `pulumi:"subnet"`
	// Tags for the Virtual Circuit resource.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// UUID of the VLAN to associate.
	VlanId pulumi.StringPtrOutput `pulumi:"vlanId"`
	// VNID VLAN parameter, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	Vnid pulumi.IntOutput `pulumi:"vnid"`
	// UUID of the VRF to associate.
	VrfId pulumi.StringPtrOutput `pulumi:"vrfId"`
}

// NewMetalVirtualCircuit registers a new resource with the given unique name, arguments, and options.
func NewMetalVirtualCircuit(ctx *pulumi.Context,
	name string, args *MetalVirtualCircuitArgs, opts ...pulumi.ResourceOption) (*MetalVirtualCircuit, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectionId == nil {
		return nil, errors.New("invalid value for required argument 'ConnectionId'")
	}
	if args.PortId == nil {
		return nil, errors.New("invalid value for required argument 'PortId'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource MetalVirtualCircuit
	err := ctx.RegisterResource("equinix:index/metalVirtualCircuit:MetalVirtualCircuit", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMetalVirtualCircuit gets an existing MetalVirtualCircuit resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMetalVirtualCircuit(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MetalVirtualCircuitState, opts ...pulumi.ResourceOption) (*MetalVirtualCircuit, error) {
	var resource MetalVirtualCircuit
	err := ctx.ReadResource("equinix:index/metalVirtualCircuit:MetalVirtualCircuit", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MetalVirtualCircuit resources.
type metalVirtualCircuitState struct {
	// UUID of Connection where the VC is scoped to.
	ConnectionId *string `pulumi:"connectionId"`
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp *string `pulumi:"customerIp"`
	// Description for the Virtual Circuit resource.
	Description *string `pulumi:"description"`
	// The password that can be set for the VRF BGP peer
	Md5 *string `pulumi:"md5"`
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp *string `pulumi:"metalIp"`
	// Name of the Virtual Circuit resource.
	Name *string `pulumi:"name"`
	// Equinix Metal network-to-network VLAN ID.
	NniVlan *int `pulumi:"nniVlan"`
	// NNI VLAN parameters, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	NniVnid *int `pulumi:"nniVnid"`
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn *int `pulumi:"peerAsn"`
	// UUID of the Connection Port where the VC is scoped to.
	PortId *string `pulumi:"portId"`
	// UUID of the Project where the VC is scoped to.
	ProjectId *string `pulumi:"projectId"`
	// Speed of the Virtual Circuit resource.
	Speed *string `pulumi:"speed"`
	// Status of the virtal circuit.
	Status *string `pulumi:"status"`
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet *string `pulumi:"subnet"`
	// Tags for the Virtual Circuit resource.
	Tags []string `pulumi:"tags"`
	// UUID of the VLAN to associate.
	VlanId *string `pulumi:"vlanId"`
	// VNID VLAN parameter, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	Vnid *int `pulumi:"vnid"`
	// UUID of the VRF to associate.
	VrfId *string `pulumi:"vrfId"`
}

type MetalVirtualCircuitState struct {
	// UUID of Connection where the VC is scoped to.
	ConnectionId pulumi.StringPtrInput
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp pulumi.StringPtrInput
	// Description for the Virtual Circuit resource.
	Description pulumi.StringPtrInput
	// The password that can be set for the VRF BGP peer
	Md5 pulumi.StringPtrInput
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp pulumi.StringPtrInput
	// Name of the Virtual Circuit resource.
	Name pulumi.StringPtrInput
	// Equinix Metal network-to-network VLAN ID.
	NniVlan pulumi.IntPtrInput
	// NNI VLAN parameters, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	NniVnid pulumi.IntPtrInput
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn pulumi.IntPtrInput
	// UUID of the Connection Port where the VC is scoped to.
	PortId pulumi.StringPtrInput
	// UUID of the Project where the VC is scoped to.
	ProjectId pulumi.StringPtrInput
	// Speed of the Virtual Circuit resource.
	Speed pulumi.StringPtrInput
	// Status of the virtal circuit.
	Status pulumi.StringPtrInput
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet pulumi.StringPtrInput
	// Tags for the Virtual Circuit resource.
	Tags pulumi.StringArrayInput
	// UUID of the VLAN to associate.
	VlanId pulumi.StringPtrInput
	// VNID VLAN parameter, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	Vnid pulumi.IntPtrInput
	// UUID of the VRF to associate.
	VrfId pulumi.StringPtrInput
}

func (MetalVirtualCircuitState) ElementType() reflect.Type {
	return reflect.TypeOf((*metalVirtualCircuitState)(nil)).Elem()
}

type metalVirtualCircuitArgs struct {
	// UUID of Connection where the VC is scoped to.
	ConnectionId string `pulumi:"connectionId"`
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp *string `pulumi:"customerIp"`
	// Description for the Virtual Circuit resource.
	Description *string `pulumi:"description"`
	// The password that can be set for the VRF BGP peer
	Md5 *string `pulumi:"md5"`
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp *string `pulumi:"metalIp"`
	// Name of the Virtual Circuit resource.
	Name *string `pulumi:"name"`
	// Equinix Metal network-to-network VLAN ID.
	NniVlan *int `pulumi:"nniVlan"`
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn *int `pulumi:"peerAsn"`
	// UUID of the Connection Port where the VC is scoped to.
	PortId string `pulumi:"portId"`
	// UUID of the Project where the VC is scoped to.
	ProjectId string `pulumi:"projectId"`
	// Speed of the Virtual Circuit resource.
	Speed *string `pulumi:"speed"`
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet *string `pulumi:"subnet"`
	// Tags for the Virtual Circuit resource.
	Tags []string `pulumi:"tags"`
	// UUID of the VLAN to associate.
	VlanId *string `pulumi:"vlanId"`
	// UUID of the VRF to associate.
	VrfId *string `pulumi:"vrfId"`
}

// The set of arguments for constructing a MetalVirtualCircuit resource.
type MetalVirtualCircuitArgs struct {
	// UUID of Connection where the VC is scoped to.
	ConnectionId pulumi.StringInput
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp pulumi.StringPtrInput
	// Description for the Virtual Circuit resource.
	Description pulumi.StringPtrInput
	// The password that can be set for the VRF BGP peer
	Md5 pulumi.StringPtrInput
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp pulumi.StringPtrInput
	// Name of the Virtual Circuit resource.
	Name pulumi.StringPtrInput
	// Equinix Metal network-to-network VLAN ID.
	NniVlan pulumi.IntPtrInput
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn pulumi.IntPtrInput
	// UUID of the Connection Port where the VC is scoped to.
	PortId pulumi.StringInput
	// UUID of the Project where the VC is scoped to.
	ProjectId pulumi.StringInput
	// Speed of the Virtual Circuit resource.
	Speed pulumi.StringPtrInput
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet pulumi.StringPtrInput
	// Tags for the Virtual Circuit resource.
	Tags pulumi.StringArrayInput
	// UUID of the VLAN to associate.
	VlanId pulumi.StringPtrInput
	// UUID of the VRF to associate.
	VrfId pulumi.StringPtrInput
}

func (MetalVirtualCircuitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metalVirtualCircuitArgs)(nil)).Elem()
}

type MetalVirtualCircuitInput interface {
	pulumi.Input

	ToMetalVirtualCircuitOutput() MetalVirtualCircuitOutput
	ToMetalVirtualCircuitOutputWithContext(ctx context.Context) MetalVirtualCircuitOutput
}

func (*MetalVirtualCircuit) ElementType() reflect.Type {
	return reflect.TypeOf((**MetalVirtualCircuit)(nil)).Elem()
}

func (i *MetalVirtualCircuit) ToMetalVirtualCircuitOutput() MetalVirtualCircuitOutput {
	return i.ToMetalVirtualCircuitOutputWithContext(context.Background())
}

func (i *MetalVirtualCircuit) ToMetalVirtualCircuitOutputWithContext(ctx context.Context) MetalVirtualCircuitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalVirtualCircuitOutput)
}

// MetalVirtualCircuitArrayInput is an input type that accepts MetalVirtualCircuitArray and MetalVirtualCircuitArrayOutput values.
// You can construct a concrete instance of `MetalVirtualCircuitArrayInput` via:
//
//          MetalVirtualCircuitArray{ MetalVirtualCircuitArgs{...} }
type MetalVirtualCircuitArrayInput interface {
	pulumi.Input

	ToMetalVirtualCircuitArrayOutput() MetalVirtualCircuitArrayOutput
	ToMetalVirtualCircuitArrayOutputWithContext(context.Context) MetalVirtualCircuitArrayOutput
}

type MetalVirtualCircuitArray []MetalVirtualCircuitInput

func (MetalVirtualCircuitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetalVirtualCircuit)(nil)).Elem()
}

func (i MetalVirtualCircuitArray) ToMetalVirtualCircuitArrayOutput() MetalVirtualCircuitArrayOutput {
	return i.ToMetalVirtualCircuitArrayOutputWithContext(context.Background())
}

func (i MetalVirtualCircuitArray) ToMetalVirtualCircuitArrayOutputWithContext(ctx context.Context) MetalVirtualCircuitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalVirtualCircuitArrayOutput)
}

// MetalVirtualCircuitMapInput is an input type that accepts MetalVirtualCircuitMap and MetalVirtualCircuitMapOutput values.
// You can construct a concrete instance of `MetalVirtualCircuitMapInput` via:
//
//          MetalVirtualCircuitMap{ "key": MetalVirtualCircuitArgs{...} }
type MetalVirtualCircuitMapInput interface {
	pulumi.Input

	ToMetalVirtualCircuitMapOutput() MetalVirtualCircuitMapOutput
	ToMetalVirtualCircuitMapOutputWithContext(context.Context) MetalVirtualCircuitMapOutput
}

type MetalVirtualCircuitMap map[string]MetalVirtualCircuitInput

func (MetalVirtualCircuitMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetalVirtualCircuit)(nil)).Elem()
}

func (i MetalVirtualCircuitMap) ToMetalVirtualCircuitMapOutput() MetalVirtualCircuitMapOutput {
	return i.ToMetalVirtualCircuitMapOutputWithContext(context.Background())
}

func (i MetalVirtualCircuitMap) ToMetalVirtualCircuitMapOutputWithContext(ctx context.Context) MetalVirtualCircuitMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalVirtualCircuitMapOutput)
}

type MetalVirtualCircuitOutput struct{ *pulumi.OutputState }

func (MetalVirtualCircuitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetalVirtualCircuit)(nil)).Elem()
}

func (o MetalVirtualCircuitOutput) ToMetalVirtualCircuitOutput() MetalVirtualCircuitOutput {
	return o
}

func (o MetalVirtualCircuitOutput) ToMetalVirtualCircuitOutputWithContext(ctx context.Context) MetalVirtualCircuitOutput {
	return o
}

// UUID of Connection where the VC is scoped to.
func (o MetalVirtualCircuitOutput) ConnectionId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringOutput { return v.ConnectionId }).(pulumi.StringOutput)
}

// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
func (o MetalVirtualCircuitOutput) CustomerIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringPtrOutput { return v.CustomerIp }).(pulumi.StringPtrOutput)
}

// Description for the Virtual Circuit resource.
func (o MetalVirtualCircuitOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The password that can be set for the VRF BGP peer
func (o MetalVirtualCircuitOutput) Md5() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringPtrOutput { return v.Md5 }).(pulumi.StringPtrOutput)
}

// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
func (o MetalVirtualCircuitOutput) MetalIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringPtrOutput { return v.MetalIp }).(pulumi.StringPtrOutput)
}

// Name of the Virtual Circuit resource.
func (o MetalVirtualCircuitOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Equinix Metal network-to-network VLAN ID.
func (o MetalVirtualCircuitOutput) NniVlan() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.IntPtrOutput { return v.NniVlan }).(pulumi.IntPtrOutput)
}

// NNI VLAN parameters, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
func (o MetalVirtualCircuitOutput) NniVnid() pulumi.IntOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.IntOutput { return v.NniVnid }).(pulumi.IntOutput)
}

// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
func (o MetalVirtualCircuitOutput) PeerAsn() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.IntPtrOutput { return v.PeerAsn }).(pulumi.IntPtrOutput)
}

// UUID of the Connection Port where the VC is scoped to.
func (o MetalVirtualCircuitOutput) PortId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringOutput { return v.PortId }).(pulumi.StringOutput)
}

// UUID of the Project where the VC is scoped to.
func (o MetalVirtualCircuitOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Speed of the Virtual Circuit resource.
func (o MetalVirtualCircuitOutput) Speed() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringOutput { return v.Speed }).(pulumi.StringOutput)
}

// Status of the virtal circuit.
func (o MetalVirtualCircuitOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// A subnet from one of the IP
// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
// * For a /31 block, it will only have two IP addresses, which will be used for
//   the metalIp and customer_ip.
// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
func (o MetalVirtualCircuitOutput) Subnet() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringPtrOutput { return v.Subnet }).(pulumi.StringPtrOutput)
}

// Tags for the Virtual Circuit resource.
func (o MetalVirtualCircuitOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// UUID of the VLAN to associate.
func (o MetalVirtualCircuitOutput) VlanId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringPtrOutput { return v.VlanId }).(pulumi.StringPtrOutput)
}

// VNID VLAN parameter, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
func (o MetalVirtualCircuitOutput) Vnid() pulumi.IntOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.IntOutput { return v.Vnid }).(pulumi.IntOutput)
}

// UUID of the VRF to associate.
func (o MetalVirtualCircuitOutput) VrfId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalVirtualCircuit) pulumi.StringPtrOutput { return v.VrfId }).(pulumi.StringPtrOutput)
}

type MetalVirtualCircuitArrayOutput struct{ *pulumi.OutputState }

func (MetalVirtualCircuitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetalVirtualCircuit)(nil)).Elem()
}

func (o MetalVirtualCircuitArrayOutput) ToMetalVirtualCircuitArrayOutput() MetalVirtualCircuitArrayOutput {
	return o
}

func (o MetalVirtualCircuitArrayOutput) ToMetalVirtualCircuitArrayOutputWithContext(ctx context.Context) MetalVirtualCircuitArrayOutput {
	return o
}

func (o MetalVirtualCircuitArrayOutput) Index(i pulumi.IntInput) MetalVirtualCircuitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MetalVirtualCircuit {
		return vs[0].([]*MetalVirtualCircuit)[vs[1].(int)]
	}).(MetalVirtualCircuitOutput)
}

type MetalVirtualCircuitMapOutput struct{ *pulumi.OutputState }

func (MetalVirtualCircuitMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetalVirtualCircuit)(nil)).Elem()
}

func (o MetalVirtualCircuitMapOutput) ToMetalVirtualCircuitMapOutput() MetalVirtualCircuitMapOutput {
	return o
}

func (o MetalVirtualCircuitMapOutput) ToMetalVirtualCircuitMapOutputWithContext(ctx context.Context) MetalVirtualCircuitMapOutput {
	return o
}

func (o MetalVirtualCircuitMapOutput) MapIndex(k pulumi.StringInput) MetalVirtualCircuitOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MetalVirtualCircuit {
		return vs[0].(map[string]*MetalVirtualCircuit)[vs[1].(string)]
	}).(MetalVirtualCircuitOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetalVirtualCircuitInput)(nil)).Elem(), &MetalVirtualCircuit{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetalVirtualCircuitArrayInput)(nil)).Elem(), MetalVirtualCircuitArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetalVirtualCircuitMapInput)(nil)).Elem(), MetalVirtualCircuitMap{})
	pulumi.RegisterOutputType(MetalVirtualCircuitOutput{})
	pulumi.RegisterOutputType(MetalVirtualCircuitArrayOutput{})
	pulumi.RegisterOutputType(MetalVirtualCircuitMapOutput{})
}
