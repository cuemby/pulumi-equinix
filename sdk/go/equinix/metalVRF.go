// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package equinix

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to manage a VRF.
//
// > VRF features are not generally available. The interfaces related to VRF resources may change ahead of general availability.
//
// ## Import
//
// This resource can be imported using an existing VRF ID
//
// ```sh
//  $ pulumi import equinix:index/metalVRF:MetalVRF equinix_metal_vrf {existing_id}
// ```
type MetalVRF struct {
	pulumi.CustomResourceState

	// Description of the VRF.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges pulumi.StringArrayOutput `pulumi:"ipRanges"`
	// The 4-byte ASN set on the VRF.
	LocalAsn pulumi.IntOutput `pulumi:"localAsn"`
	// Metro ID or Code where the VRF will be deployed.
	Metro pulumi.StringOutput `pulumi:"metro"`
	// User-supplied name of the VRF, unique to the project
	Name pulumi.StringOutput `pulumi:"name"`
	// Project ID where the VRF will be deployed.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
}

// NewMetalVRF registers a new resource with the given unique name, arguments, and options.
func NewMetalVRF(ctx *pulumi.Context,
	name string, args *MetalVRFArgs, opts ...pulumi.ResourceOption) (*MetalVRF, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Metro == nil {
		return nil, errors.New("invalid value for required argument 'Metro'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource MetalVRF
	err := ctx.RegisterResource("equinix:index/metalVRF:MetalVRF", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMetalVRF gets an existing MetalVRF resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMetalVRF(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MetalVRFState, opts ...pulumi.ResourceOption) (*MetalVRF, error) {
	var resource MetalVRF
	err := ctx.ReadResource("equinix:index/metalVRF:MetalVRF", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MetalVRF resources.
type metalVRFState struct {
	// Description of the VRF.
	Description *string `pulumi:"description"`
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges []string `pulumi:"ipRanges"`
	// The 4-byte ASN set on the VRF.
	LocalAsn *int `pulumi:"localAsn"`
	// Metro ID or Code where the VRF will be deployed.
	Metro *string `pulumi:"metro"`
	// User-supplied name of the VRF, unique to the project
	Name *string `pulumi:"name"`
	// Project ID where the VRF will be deployed.
	ProjectId *string `pulumi:"projectId"`
}

type MetalVRFState struct {
	// Description of the VRF.
	Description pulumi.StringPtrInput
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges pulumi.StringArrayInput
	// The 4-byte ASN set on the VRF.
	LocalAsn pulumi.IntPtrInput
	// Metro ID or Code where the VRF will be deployed.
	Metro pulumi.StringPtrInput
	// User-supplied name of the VRF, unique to the project
	Name pulumi.StringPtrInput
	// Project ID where the VRF will be deployed.
	ProjectId pulumi.StringPtrInput
}

func (MetalVRFState) ElementType() reflect.Type {
	return reflect.TypeOf((*metalVRFState)(nil)).Elem()
}

type metalVRFArgs struct {
	// Description of the VRF.
	Description *string `pulumi:"description"`
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges []string `pulumi:"ipRanges"`
	// The 4-byte ASN set on the VRF.
	LocalAsn *int `pulumi:"localAsn"`
	// Metro ID or Code where the VRF will be deployed.
	Metro string `pulumi:"metro"`
	// User-supplied name of the VRF, unique to the project
	Name *string `pulumi:"name"`
	// Project ID where the VRF will be deployed.
	ProjectId string `pulumi:"projectId"`
}

// The set of arguments for constructing a MetalVRF resource.
type MetalVRFArgs struct {
	// Description of the VRF.
	Description pulumi.StringPtrInput
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges pulumi.StringArrayInput
	// The 4-byte ASN set on the VRF.
	LocalAsn pulumi.IntPtrInput
	// Metro ID or Code where the VRF will be deployed.
	Metro pulumi.StringInput
	// User-supplied name of the VRF, unique to the project
	Name pulumi.StringPtrInput
	// Project ID where the VRF will be deployed.
	ProjectId pulumi.StringInput
}

func (MetalVRFArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metalVRFArgs)(nil)).Elem()
}

type MetalVRFInput interface {
	pulumi.Input

	ToMetalVRFOutput() MetalVRFOutput
	ToMetalVRFOutputWithContext(ctx context.Context) MetalVRFOutput
}

func (*MetalVRF) ElementType() reflect.Type {
	return reflect.TypeOf((**MetalVRF)(nil)).Elem()
}

func (i *MetalVRF) ToMetalVRFOutput() MetalVRFOutput {
	return i.ToMetalVRFOutputWithContext(context.Background())
}

func (i *MetalVRF) ToMetalVRFOutputWithContext(ctx context.Context) MetalVRFOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalVRFOutput)
}

// MetalVRFArrayInput is an input type that accepts MetalVRFArray and MetalVRFArrayOutput values.
// You can construct a concrete instance of `MetalVRFArrayInput` via:
//
//          MetalVRFArray{ MetalVRFArgs{...} }
type MetalVRFArrayInput interface {
	pulumi.Input

	ToMetalVRFArrayOutput() MetalVRFArrayOutput
	ToMetalVRFArrayOutputWithContext(context.Context) MetalVRFArrayOutput
}

type MetalVRFArray []MetalVRFInput

func (MetalVRFArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetalVRF)(nil)).Elem()
}

func (i MetalVRFArray) ToMetalVRFArrayOutput() MetalVRFArrayOutput {
	return i.ToMetalVRFArrayOutputWithContext(context.Background())
}

func (i MetalVRFArray) ToMetalVRFArrayOutputWithContext(ctx context.Context) MetalVRFArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalVRFArrayOutput)
}

// MetalVRFMapInput is an input type that accepts MetalVRFMap and MetalVRFMapOutput values.
// You can construct a concrete instance of `MetalVRFMapInput` via:
//
//          MetalVRFMap{ "key": MetalVRFArgs{...} }
type MetalVRFMapInput interface {
	pulumi.Input

	ToMetalVRFMapOutput() MetalVRFMapOutput
	ToMetalVRFMapOutputWithContext(context.Context) MetalVRFMapOutput
}

type MetalVRFMap map[string]MetalVRFInput

func (MetalVRFMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetalVRF)(nil)).Elem()
}

func (i MetalVRFMap) ToMetalVRFMapOutput() MetalVRFMapOutput {
	return i.ToMetalVRFMapOutputWithContext(context.Background())
}

func (i MetalVRFMap) ToMetalVRFMapOutputWithContext(ctx context.Context) MetalVRFMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalVRFMapOutput)
}

type MetalVRFOutput struct{ *pulumi.OutputState }

func (MetalVRFOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetalVRF)(nil)).Elem()
}

func (o MetalVRFOutput) ToMetalVRFOutput() MetalVRFOutput {
	return o
}

func (o MetalVRFOutput) ToMetalVRFOutputWithContext(ctx context.Context) MetalVRFOutput {
	return o
}

// Description of the VRF.
func (o MetalVRFOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetalVRF) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
func (o MetalVRFOutput) IpRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *MetalVRF) pulumi.StringArrayOutput { return v.IpRanges }).(pulumi.StringArrayOutput)
}

// The 4-byte ASN set on the VRF.
func (o MetalVRFOutput) LocalAsn() pulumi.IntOutput {
	return o.ApplyT(func(v *MetalVRF) pulumi.IntOutput { return v.LocalAsn }).(pulumi.IntOutput)
}

// Metro ID or Code where the VRF will be deployed.
func (o MetalVRFOutput) Metro() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVRF) pulumi.StringOutput { return v.Metro }).(pulumi.StringOutput)
}

// User-supplied name of the VRF, unique to the project
func (o MetalVRFOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVRF) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Project ID where the VRF will be deployed.
func (o MetalVRFOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalVRF) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

type MetalVRFArrayOutput struct{ *pulumi.OutputState }

func (MetalVRFArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetalVRF)(nil)).Elem()
}

func (o MetalVRFArrayOutput) ToMetalVRFArrayOutput() MetalVRFArrayOutput {
	return o
}

func (o MetalVRFArrayOutput) ToMetalVRFArrayOutputWithContext(ctx context.Context) MetalVRFArrayOutput {
	return o
}

func (o MetalVRFArrayOutput) Index(i pulumi.IntInput) MetalVRFOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MetalVRF {
		return vs[0].([]*MetalVRF)[vs[1].(int)]
	}).(MetalVRFOutput)
}

type MetalVRFMapOutput struct{ *pulumi.OutputState }

func (MetalVRFMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetalVRF)(nil)).Elem()
}

func (o MetalVRFMapOutput) ToMetalVRFMapOutput() MetalVRFMapOutput {
	return o
}

func (o MetalVRFMapOutput) ToMetalVRFMapOutputWithContext(ctx context.Context) MetalVRFMapOutput {
	return o
}

func (o MetalVRFMapOutput) MapIndex(k pulumi.StringInput) MetalVRFOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MetalVRF {
		return vs[0].(map[string]*MetalVRF)[vs[1].(string)]
	}).(MetalVRFOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetalVRFInput)(nil)).Elem(), &MetalVRF{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetalVRFArrayInput)(nil)).Elem(), MetalVRFArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetalVRFMapInput)(nil)).Elem(), MetalVRFMap{})
	pulumi.RegisterOutputType(MetalVRFOutput{})
	pulumi.RegisterOutputType(MetalVRFArrayOutput{})
	pulumi.RegisterOutputType(MetalVRFMapOutput{})
}
