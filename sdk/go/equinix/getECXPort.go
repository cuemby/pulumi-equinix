// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package equinix

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this data source to get details of Equinix Fabric port with a given name.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-equinix/sdk/go/equinix"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		tf_pri_dot1q, err := equinix.GetECXPort(ctx, &GetECXPortArgs{
// 			Name: "sit-001-CX-NY5-NL-Dot1q-BO-10G-PRI-JP-157",
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		ctx.Export("id", tf_pri_dot1q.Id)
// 		return nil
// 	})
// }
// ```
func GetECXPort(ctx *pulumi.Context, args *GetECXPortArgs, opts ...pulumi.InvokeOption) (*GetECXPortResult, error) {
	var rv GetECXPortResult
	err := ctx.Invoke("equinix:index/getECXPort:GetECXPort", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

// A collection of arguments for invoking GetECXPort.
type GetECXPortArgs struct {
	// Name of the port.
	Name string `pulumi:"name"`
}

// A collection of values returned by GetECXPort.
type GetECXPortResult struct {
	// Port Bandwidth in bytes.
	Bandwidth string `pulumi:"bandwidth"`
	// Boolean value that indicates whether the port supports unlimited connections. If
	// `false`, the port is a standard port with limited connections. If `true`, the port is an
	// `unlimited connections` port that allows multiple connections at no additional charge.
	Buyout bool `pulumi:"buyout"`
	// The VLAN encapsulation of the port (Dot1q or QinQ).
	Encapsulation string `pulumi:"encapsulation"`
	// Port location Equinix Business Exchange (IBX).
	Ibx string `pulumi:"ibx"`
	// The provider-assigned unique ID for this managed resource.
	Id string `pulumi:"id"`
	// Port location metro code.
	MetroCode string `pulumi:"metroCode"`
	Name      string `pulumi:"name"`
	// The priority of the device (primary / secondary) where the port
	// resides.
	Priority string `pulumi:"priority"`
	// Port location region.
	Region string `pulumi:"region"`
	// Port status that indicates whether a port has been assigned or is ready for
	// connection.
	Status string `pulumi:"status"`
	// Unique identifier of the port.
	Uuid string `pulumi:"uuid"`
}

func GetECXPortOutput(ctx *pulumi.Context, args GetECXPortOutputArgs, opts ...pulumi.InvokeOption) GetECXPortResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (GetECXPortResult, error) {
			args := v.(GetECXPortArgs)
			r, err := GetECXPort(ctx, &args, opts...)
			var s GetECXPortResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(GetECXPortResultOutput)
}

// A collection of arguments for invoking GetECXPort.
type GetECXPortOutputArgs struct {
	// Name of the port.
	Name pulumi.StringInput `pulumi:"name"`
}

func (GetECXPortOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetECXPortArgs)(nil)).Elem()
}

// A collection of values returned by GetECXPort.
type GetECXPortResultOutput struct{ *pulumi.OutputState }

func (GetECXPortResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetECXPortResult)(nil)).Elem()
}

func (o GetECXPortResultOutput) ToGetECXPortResultOutput() GetECXPortResultOutput {
	return o
}

func (o GetECXPortResultOutput) ToGetECXPortResultOutputWithContext(ctx context.Context) GetECXPortResultOutput {
	return o
}

// Port Bandwidth in bytes.
func (o GetECXPortResultOutput) Bandwidth() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Bandwidth }).(pulumi.StringOutput)
}

// Boolean value that indicates whether the port supports unlimited connections. If
// `false`, the port is a standard port with limited connections. If `true`, the port is an
// `unlimited connections` port that allows multiple connections at no additional charge.
func (o GetECXPortResultOutput) Buyout() pulumi.BoolOutput {
	return o.ApplyT(func(v GetECXPortResult) bool { return v.Buyout }).(pulumi.BoolOutput)
}

// The VLAN encapsulation of the port (Dot1q or QinQ).
func (o GetECXPortResultOutput) Encapsulation() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Encapsulation }).(pulumi.StringOutput)
}

// Port location Equinix Business Exchange (IBX).
func (o GetECXPortResultOutput) Ibx() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Ibx }).(pulumi.StringOutput)
}

// The provider-assigned unique ID for this managed resource.
func (o GetECXPortResultOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Id }).(pulumi.StringOutput)
}

// Port location metro code.
func (o GetECXPortResultOutput) MetroCode() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.MetroCode }).(pulumi.StringOutput)
}

func (o GetECXPortResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Name }).(pulumi.StringOutput)
}

// The priority of the device (primary / secondary) where the port
// resides.
func (o GetECXPortResultOutput) Priority() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Priority }).(pulumi.StringOutput)
}

// Port location region.
func (o GetECXPortResultOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Region }).(pulumi.StringOutput)
}

// Port status that indicates whether a port has been assigned or is ready for
// connection.
func (o GetECXPortResultOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Status }).(pulumi.StringOutput)
}

// Unique identifier of the port.
func (o GetECXPortResultOutput) Uuid() pulumi.StringOutput {
	return o.ApplyT(func(v GetECXPortResult) string { return v.Uuid }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterOutputType(GetECXPortResultOutput{})
}
