// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package equinix

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to attach elastic IP subnets to devices.
//
// To attach an IP subnet from a reserved block to a provisioned device, you must derive a subnet CIDR
// belonging to one of your reserved blocks in the same project and facility as the target device.
//
// For example, you have reserved IPv4 address block `147.229.10.152/30`, you can choose to assign
// either the whole block as one subnet to a device; or 2 subnets with CIDRs `147.229.10.152/31` and
// `147.229.10.154/31`; or 4 subnets with mask prefix length `32`. More about the elastic IP subnets
// is [here](https://metal.equinix.com/developers/docs/networking/elastic-ips/).
//
// Device and reserved block must be in the same facility.
type MetalIPAttachment struct {
	pulumi.CustomResourceState

	Address pulumi.StringOutput `pulumi:"address"`
	// Address family as integer. One of `4` or `6`.
	AddressFamily pulumi.IntOutput `pulumi:"addressFamily"`
	// Length of CIDR prefix of the subnet as integer.
	Cidr pulumi.IntOutput `pulumi:"cidr"`
	// CIDR notation of subnet from block reserved in the same project
	// and facility as the device.
	CidrNotation pulumi.StringOutput `pulumi:"cidrNotation"`
	// ID of device to which to assign the subnet.
	DeviceId pulumi.StringOutput `pulumi:"deviceId"`
	// IP address of gateway for the subnet.
	Gateway pulumi.StringOutput `pulumi:"gateway"`
	// Flag indicating whether IP block is global, i.e. assignable in any location
	Global     pulumi.BoolOutput `pulumi:"global"`
	Manageable pulumi.BoolOutput `pulumi:"manageable"`
	Management pulumi.BoolOutput `pulumi:"management"`
	// Subnet mask in decimal notation, e.g., `255.255.255.0`.
	Netmask pulumi.StringOutput `pulumi:"netmask"`
	// Subnet network address.
	Network pulumi.StringOutput `pulumi:"network"`
	// Boolean flag whether subnet is reachable from the Internet.
	Public pulumi.BoolOutput   `pulumi:"public"`
	VrfId  pulumi.StringOutput `pulumi:"vrfId"`
}

// NewMetalIPAttachment registers a new resource with the given unique name, arguments, and options.
func NewMetalIPAttachment(ctx *pulumi.Context,
	name string, args *MetalIPAttachmentArgs, opts ...pulumi.ResourceOption) (*MetalIPAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CidrNotation == nil {
		return nil, errors.New("invalid value for required argument 'CidrNotation'")
	}
	if args.DeviceId == nil {
		return nil, errors.New("invalid value for required argument 'DeviceId'")
	}
	var resource MetalIPAttachment
	err := ctx.RegisterResource("equinix:index/metalIPAttachment:MetalIPAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMetalIPAttachment gets an existing MetalIPAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMetalIPAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MetalIPAttachmentState, opts ...pulumi.ResourceOption) (*MetalIPAttachment, error) {
	var resource MetalIPAttachment
	err := ctx.ReadResource("equinix:index/metalIPAttachment:MetalIPAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MetalIPAttachment resources.
type metalIPAttachmentState struct {
	Address *string `pulumi:"address"`
	// Address family as integer. One of `4` or `6`.
	AddressFamily *int `pulumi:"addressFamily"`
	// Length of CIDR prefix of the subnet as integer.
	Cidr *int `pulumi:"cidr"`
	// CIDR notation of subnet from block reserved in the same project
	// and facility as the device.
	CidrNotation *string `pulumi:"cidrNotation"`
	// ID of device to which to assign the subnet.
	DeviceId *string `pulumi:"deviceId"`
	// IP address of gateway for the subnet.
	Gateway *string `pulumi:"gateway"`
	// Flag indicating whether IP block is global, i.e. assignable in any location
	Global     *bool `pulumi:"global"`
	Manageable *bool `pulumi:"manageable"`
	Management *bool `pulumi:"management"`
	// Subnet mask in decimal notation, e.g., `255.255.255.0`.
	Netmask *string `pulumi:"netmask"`
	// Subnet network address.
	Network *string `pulumi:"network"`
	// Boolean flag whether subnet is reachable from the Internet.
	Public *bool   `pulumi:"public"`
	VrfId  *string `pulumi:"vrfId"`
}

type MetalIPAttachmentState struct {
	Address pulumi.StringPtrInput
	// Address family as integer. One of `4` or `6`.
	AddressFamily pulumi.IntPtrInput
	// Length of CIDR prefix of the subnet as integer.
	Cidr pulumi.IntPtrInput
	// CIDR notation of subnet from block reserved in the same project
	// and facility as the device.
	CidrNotation pulumi.StringPtrInput
	// ID of device to which to assign the subnet.
	DeviceId pulumi.StringPtrInput
	// IP address of gateway for the subnet.
	Gateway pulumi.StringPtrInput
	// Flag indicating whether IP block is global, i.e. assignable in any location
	Global     pulumi.BoolPtrInput
	Manageable pulumi.BoolPtrInput
	Management pulumi.BoolPtrInput
	// Subnet mask in decimal notation, e.g., `255.255.255.0`.
	Netmask pulumi.StringPtrInput
	// Subnet network address.
	Network pulumi.StringPtrInput
	// Boolean flag whether subnet is reachable from the Internet.
	Public pulumi.BoolPtrInput
	VrfId  pulumi.StringPtrInput
}

func (MetalIPAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*metalIPAttachmentState)(nil)).Elem()
}

type metalIPAttachmentArgs struct {
	// CIDR notation of subnet from block reserved in the same project
	// and facility as the device.
	CidrNotation string `pulumi:"cidrNotation"`
	// ID of device to which to assign the subnet.
	DeviceId string `pulumi:"deviceId"`
}

// The set of arguments for constructing a MetalIPAttachment resource.
type MetalIPAttachmentArgs struct {
	// CIDR notation of subnet from block reserved in the same project
	// and facility as the device.
	CidrNotation pulumi.StringInput
	// ID of device to which to assign the subnet.
	DeviceId pulumi.StringInput
}

func (MetalIPAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metalIPAttachmentArgs)(nil)).Elem()
}

type MetalIPAttachmentInput interface {
	pulumi.Input

	ToMetalIPAttachmentOutput() MetalIPAttachmentOutput
	ToMetalIPAttachmentOutputWithContext(ctx context.Context) MetalIPAttachmentOutput
}

func (*MetalIPAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**MetalIPAttachment)(nil)).Elem()
}

func (i *MetalIPAttachment) ToMetalIPAttachmentOutput() MetalIPAttachmentOutput {
	return i.ToMetalIPAttachmentOutputWithContext(context.Background())
}

func (i *MetalIPAttachment) ToMetalIPAttachmentOutputWithContext(ctx context.Context) MetalIPAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalIPAttachmentOutput)
}

// MetalIPAttachmentArrayInput is an input type that accepts MetalIPAttachmentArray and MetalIPAttachmentArrayOutput values.
// You can construct a concrete instance of `MetalIPAttachmentArrayInput` via:
//
//          MetalIPAttachmentArray{ MetalIPAttachmentArgs{...} }
type MetalIPAttachmentArrayInput interface {
	pulumi.Input

	ToMetalIPAttachmentArrayOutput() MetalIPAttachmentArrayOutput
	ToMetalIPAttachmentArrayOutputWithContext(context.Context) MetalIPAttachmentArrayOutput
}

type MetalIPAttachmentArray []MetalIPAttachmentInput

func (MetalIPAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetalIPAttachment)(nil)).Elem()
}

func (i MetalIPAttachmentArray) ToMetalIPAttachmentArrayOutput() MetalIPAttachmentArrayOutput {
	return i.ToMetalIPAttachmentArrayOutputWithContext(context.Background())
}

func (i MetalIPAttachmentArray) ToMetalIPAttachmentArrayOutputWithContext(ctx context.Context) MetalIPAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalIPAttachmentArrayOutput)
}

// MetalIPAttachmentMapInput is an input type that accepts MetalIPAttachmentMap and MetalIPAttachmentMapOutput values.
// You can construct a concrete instance of `MetalIPAttachmentMapInput` via:
//
//          MetalIPAttachmentMap{ "key": MetalIPAttachmentArgs{...} }
type MetalIPAttachmentMapInput interface {
	pulumi.Input

	ToMetalIPAttachmentMapOutput() MetalIPAttachmentMapOutput
	ToMetalIPAttachmentMapOutputWithContext(context.Context) MetalIPAttachmentMapOutput
}

type MetalIPAttachmentMap map[string]MetalIPAttachmentInput

func (MetalIPAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetalIPAttachment)(nil)).Elem()
}

func (i MetalIPAttachmentMap) ToMetalIPAttachmentMapOutput() MetalIPAttachmentMapOutput {
	return i.ToMetalIPAttachmentMapOutputWithContext(context.Background())
}

func (i MetalIPAttachmentMap) ToMetalIPAttachmentMapOutputWithContext(ctx context.Context) MetalIPAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetalIPAttachmentMapOutput)
}

type MetalIPAttachmentOutput struct{ *pulumi.OutputState }

func (MetalIPAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetalIPAttachment)(nil)).Elem()
}

func (o MetalIPAttachmentOutput) ToMetalIPAttachmentOutput() MetalIPAttachmentOutput {
	return o
}

func (o MetalIPAttachmentOutput) ToMetalIPAttachmentOutputWithContext(ctx context.Context) MetalIPAttachmentOutput {
	return o
}

func (o MetalIPAttachmentOutput) Address() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.StringOutput { return v.Address }).(pulumi.StringOutput)
}

// Address family as integer. One of `4` or `6`.
func (o MetalIPAttachmentOutput) AddressFamily() pulumi.IntOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.IntOutput { return v.AddressFamily }).(pulumi.IntOutput)
}

// Length of CIDR prefix of the subnet as integer.
func (o MetalIPAttachmentOutput) Cidr() pulumi.IntOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.IntOutput { return v.Cidr }).(pulumi.IntOutput)
}

// CIDR notation of subnet from block reserved in the same project
// and facility as the device.
func (o MetalIPAttachmentOutput) CidrNotation() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.StringOutput { return v.CidrNotation }).(pulumi.StringOutput)
}

// ID of device to which to assign the subnet.
func (o MetalIPAttachmentOutput) DeviceId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.StringOutput { return v.DeviceId }).(pulumi.StringOutput)
}

// IP address of gateway for the subnet.
func (o MetalIPAttachmentOutput) Gateway() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.StringOutput { return v.Gateway }).(pulumi.StringOutput)
}

// Flag indicating whether IP block is global, i.e. assignable in any location
func (o MetalIPAttachmentOutput) Global() pulumi.BoolOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.BoolOutput { return v.Global }).(pulumi.BoolOutput)
}

func (o MetalIPAttachmentOutput) Manageable() pulumi.BoolOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.BoolOutput { return v.Manageable }).(pulumi.BoolOutput)
}

func (o MetalIPAttachmentOutput) Management() pulumi.BoolOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.BoolOutput { return v.Management }).(pulumi.BoolOutput)
}

// Subnet mask in decimal notation, e.g., `255.255.255.0`.
func (o MetalIPAttachmentOutput) Netmask() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.StringOutput { return v.Netmask }).(pulumi.StringOutput)
}

// Subnet network address.
func (o MetalIPAttachmentOutput) Network() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.StringOutput { return v.Network }).(pulumi.StringOutput)
}

// Boolean flag whether subnet is reachable from the Internet.
func (o MetalIPAttachmentOutput) Public() pulumi.BoolOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.BoolOutput { return v.Public }).(pulumi.BoolOutput)
}

func (o MetalIPAttachmentOutput) VrfId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetalIPAttachment) pulumi.StringOutput { return v.VrfId }).(pulumi.StringOutput)
}

type MetalIPAttachmentArrayOutput struct{ *pulumi.OutputState }

func (MetalIPAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetalIPAttachment)(nil)).Elem()
}

func (o MetalIPAttachmentArrayOutput) ToMetalIPAttachmentArrayOutput() MetalIPAttachmentArrayOutput {
	return o
}

func (o MetalIPAttachmentArrayOutput) ToMetalIPAttachmentArrayOutputWithContext(ctx context.Context) MetalIPAttachmentArrayOutput {
	return o
}

func (o MetalIPAttachmentArrayOutput) Index(i pulumi.IntInput) MetalIPAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MetalIPAttachment {
		return vs[0].([]*MetalIPAttachment)[vs[1].(int)]
	}).(MetalIPAttachmentOutput)
}

type MetalIPAttachmentMapOutput struct{ *pulumi.OutputState }

func (MetalIPAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetalIPAttachment)(nil)).Elem()
}

func (o MetalIPAttachmentMapOutput) ToMetalIPAttachmentMapOutput() MetalIPAttachmentMapOutput {
	return o
}

func (o MetalIPAttachmentMapOutput) ToMetalIPAttachmentMapOutputWithContext(ctx context.Context) MetalIPAttachmentMapOutput {
	return o
}

func (o MetalIPAttachmentMapOutput) MapIndex(k pulumi.StringInput) MetalIPAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MetalIPAttachment {
		return vs[0].(map[string]*MetalIPAttachment)[vs[1].(string)]
	}).(MetalIPAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetalIPAttachmentInput)(nil)).Elem(), &MetalIPAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetalIPAttachmentArrayInput)(nil)).Elem(), MetalIPAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetalIPAttachmentMapInput)(nil)).Elem(), MetalIPAttachmentMap{})
	pulumi.RegisterOutputType(MetalIPAttachmentOutput{})
	pulumi.RegisterOutputType(MetalIPAttachmentArrayOutput{})
	pulumi.RegisterOutputType(MetalIPAttachmentMapOutput{})
}
