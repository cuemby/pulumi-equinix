// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ECXL2ConnectionAction {
    message: string;
    operationId: string;
    requiredDatas: outputs.ECXL2ConnectionActionRequiredData[];
    type: string;
}

export interface ECXL2ConnectionActionRequiredData {
    editable: boolean;
    key: string;
    label: string;
    validationPattern: string;
    /**
     * additional information value
     */
    value: string;
}

export interface ECXL2ConnectionAdditionalInfo {
    /**
     * additional information key
     */
    name: string;
    /**
     * additional information value
     */
    value: string;
}

export interface ECXL2ConnectionSecondaryConnection {
    /**
     * One or more pending actions to complete connection provisioning.
     */
    actions: outputs.ECXL2ConnectionSecondaryConnectionAction[];
    /**
     * Unique identifier authorizing Equinix to provision a connection
     * towards a cloud service provider. If not specified primary `authorizationKey` will be used. However,
     * some service providers may require different keys for each connection. More information on
     * [Equinix Fabric how to guide](https://developer.equinix.com/docs/ecx-how-to-guide).
     */
    authorizationKey: string;
    /**
     * Applicable with `deviceUuid`, identifier of network interface
     * on a given device. If not specified then first available interface will be selected.
     */
    deviceInterfaceId: number;
    /**
     * Applicable with primary `deviceUuid`. Identifier of the Network Edge
     * virtual device from which the secondary connection would originate. If not specified primary
     * `deviceUuid` will be used.
     */
    deviceUuid?: string;
    /**
     * secondary connection name
     */
    name: string;
    /**
     * Applicable with primary `portUuid`. Identifier of the Equinix Fabric Port from
     * which the secondary connection would originate. If not specified primary `portUuid` will be used.
     */
    portUuid: string;
    /**
     * Unique identifier of the service provider's profile.
     */
    profileUuid: string;
    /**
     * Connection provisioning status on service provider's side.
     */
    providerStatus: string;
    /**
     * Unique identifier of group containing a primary and secondary connection.
     */
    redundancyGroup: string;
    /**
     * Connection redundancy type, applicable for HA connections. Valid values are
     * `PRIMARY`, `SECONDARY`.
     */
    redundancyType: string;
    /**
     * Unique identifier of the redundant connection, applicable for HA connections.
     *
     * @deprecated SecondaryConnection.0.RedundantUUID will not be returned. Use UUID instead
     */
    redundantUuid: string;
    /**
     * The metro code that denotes the secondary connectionâ€™s
     * destination (Z side). .
     */
    sellerMetroCode: string;
    /**
     * The region in which the seller port resides. If not specified
     * primary `sellerRegion` will be used.
     */
    sellerRegion: string;
    /**
     * Required with primary `serviceToken`. Unique Equinix Fabric key
     * given by a provider that grants you authorization to enable connectivity from an Equinix Fabric Port or
     * virtual device. Each connection (primary and secondary) requires a separate token.
     * More details in [Fabric Service Tokens](https://docs.equinix.com/en-us/Content/Interconnection/Fabric/service%20tokens/Fabric-Service-Tokens.htm).
     */
    serviceToken?: string;
    /**
     * Speed/Bandwidth to be allocated to the secondary connection. If not
     * specified primary `speed` will be used.
     */
    speed: number;
    /**
     * Unit of the speed/bandwidth to be allocated to the secondary
     * connection. If not specified primary `speedUnit` will be used.
     */
    speedUnit: string;
    /**
     * Connection provisioning status on Equinix Fabric side.
     */
    status: string;
    /**
     * Unique identifier of the connection.
     */
    uuid: string;
    /**
     * The Equinix Fabric Token the connection was created with. Applicable if the
     * connection was created with a `serviceToken` (a-side) or `zsideServiceToken` (z-side).
     * * `secondaryConnection`:
     * * `zsidePortUuid`
     * * `zsideVlanStag`
     * * `zsideVlanCtag`
     * * `redundancyType`
     * * `redundancyGroup`
     * * `vendorToken`
     */
    vendorToken: string;
    /**
     * Applicable with `portUuid`. C-Tag/Inner-Tag of the secondary
     * connection, a numeric character ranging from 2 - 4094.
     */
    vlanCtag?: number;
    /**
     * S-Tag/Outer-Tag of the secondary connection, a
     * numeric character ranging from 2 - 4094.
     */
    vlanStag: number;
    /**
     * Unique identifier of the port on the remote/destination side
     * (z-side). Allows you to connect between your own ports or virtual devices across your company's
     * Equinix Fabric deployment, with no need for a private service profile.
     */
    zsidePortUuid: string;
    /**
     * C-Tag/Inner-Tag of the connection on the remote/destination
     * side (z-side) - a numeric character ranging from 2 - 4094.
     * `secondaryConnection` is defined it will internally use same `zsideVlanCtag` for the secondary
     * connection.
     */
    zsideVlanCtag: number;
    /**
     * S-Tag/Outer-Tag of the connection on the remote/destination
     * side (z-side) - a numeric character ranging from 2 - 4094.
     */
    zsideVlanStag: number;
}

export interface ECXL2ConnectionSecondaryConnectionAction {
    message: string;
    operationId: string;
    requiredDatas: outputs.ECXL2ConnectionSecondaryConnectionActionRequiredData[];
    type: string;
}

export interface ECXL2ConnectionSecondaryConnectionActionRequiredData {
    editable: boolean;
    key: string;
    label: string;
    validationPattern: string;
    /**
     * additional information value
     */
    value: string;
}

export interface ECXL2ServiceprofileFeatures {
    /**
     * Indicates whether or not connections to this profile
     * can be created from remote metro locations.
     */
    allowRemoteConnections: boolean;
    /**
     * Indicates whether or not this profile can be used for test
     * connections.
     *
     * @deprecated TestProfile is no longer required and will be removed in a future release
     */
    testProfile?: boolean;
}

export interface ECXL2ServiceprofilePort {
    /**
     * The metro code of location where the port resides.
     */
    metroCode: string;
    /**
     * Unique identifier of the port.
     */
    uuid: string;
}

export interface ECXL2ServiceprofileSpeedBand {
    /**
     * Speed/bandwidth supported by this service profile.
     */
    speed: number;
    /**
     * Unit of the speed/bandwidth supported by this service profile. One of
     * `MB`, `GB`.
     */
    speedUnit: string;
}

export interface GetECXL2SellerprofileAdditionalInfo {
    capturedInEmail: boolean;
    /**
     * Data type of additional information attribute. One of `BOOLEAN`, `INTEGER` or
     * `STRING`.
     */
    dataType: string;
    /**
     * Textual description of additional information attribute.
     */
    description: string;
    /**
     * Specifies if additional information is mandatory to create
     * connection.
     */
    mandatory: boolean;
    /**
     * Name of the seller profile.
     */
    name: string;
}

export interface GetECXL2SellerprofileMetro {
    /**
     * Location metro code.
     */
    code: string;
    /**
     * List of IBXes supported within given metro.
     */
    ibxes: string[];
    /**
     * Name of the seller profile.
     */
    name: string;
    /**
     * List of regions supported within given.
     */
    regions: {[key: string]: string};
}

export interface GetECXL2SellerprofileSpeedBand {
    /**
     * Speed/bandwidth supported by given service profile.
     */
    speed: number;
    /**
     * Unit of the speed/bandwidth supported by given service profile.
     */
    speedUnit: string;
}

export interface GetECXL2SellerprofilesProfile {
    additionalInfos: outputs.GetECXL2SellerprofilesProfileAdditionalInfo[];
    description: string;
    encapsulation: string;
    metros: outputs.GetECXL2SellerprofilesProfileMetro[];
    name: string;
    /**
     * Name of seller's global organization.
     */
    organizationGlobalName: string;
    /**
     * Name of seller's organization.
     */
    organizationName: string;
    redundancyRequired: boolean;
    speedBands: outputs.GetECXL2SellerprofilesProfileSpeedBand[];
    speedCustomizationAllowed: boolean;
    speedFromApi: boolean;
    uuid: string;
}

export interface GetECXL2SellerprofilesProfileAdditionalInfo {
    capturedInEmail: boolean;
    dataType: string;
    description: string;
    mandatory: boolean;
    name: string;
}

export interface GetECXL2SellerprofilesProfileMetro {
    code: string;
    ibxes: string[];
    name: string;
    regions: {[key: string]: string};
}

export interface GetECXL2SellerprofilesProfileSpeedBand {
    speed: number;
    speedUnit: string;
}

export interface GetMetalConnectionPort {
    /**
     * Port UUID.
     */
    id: string;
    /**
     * Port link status.
     */
    linkStatus: string;
    /**
     * Port name.
     */
    name: string;
    /**
     * Port role - primary or secondary.
     */
    role: string;
    /**
     * Port speed in bits per second.
     */
    speed: number;
    /**
     * Port status.
     */
    status: string;
    /**
     * List of IDs of virtual cicruits attached to this port.
     */
    virtualCircuitIds: any[];
}

export interface GetMetalConnectionServiceToken {
    /**
     * Expiration date of the service token.
     */
    expiresAt: string;
    /**
     * Port UUID.
     */
    id: string;
    /**
     * Maximum allowed speed for the service token, string like in the `speed` attribute.
     */
    maxAllowedSpeed: string;
    /**
     * Port role - primary or secondary.
     */
    role: string;
    state: string;
    /**
     * Token type, `aSide` or `zSide`.
     */
    type: string;
}

export interface GetMetalDeviceBGPNeighborsBgpNeighbor {
    /**
     * IP address version, 4 or 6.
     */
    addressFamily: number;
    /**
     * Local autonomous system number.
     */
    customerAs: number;
    /**
     * Local used peer IP address.
     */
    customerIp: string;
    /**
     * Whether BGP session is password enabled.
     */
    md5Enabled: boolean;
    /**
     * BGP session password in plaintext (not a checksum).
     */
    md5Password: string;
    /**
     * Whether the neighbor is in EBGP multihop session.
     */
    multihop: boolean;
    /**
     * Peer AS number (different than customerAs for EBGP).
     */
    peerAs: number;
    /**
     * Array of IP addresses of this neighbor's peers.
     */
    peerIps?: string[];
    /**
     * Array of incoming routes.
     */
    routesIns: outputs.GetMetalDeviceBGPNeighborsBgpNeighborRoutesIn[];
    /**
     * Array of outgoing routes in the same format.
     */
    routesOuts: outputs.GetMetalDeviceBGPNeighborsBgpNeighborRoutesOut[];
}

export interface GetMetalDeviceBGPNeighborsBgpNeighborRoutesIn {
    /**
     * (bool) Whether the route is exact.
     */
    exact: boolean;
    /**
     * CIDR expression of route (IP/mask).
     */
    route: string;
}

export interface GetMetalDeviceBGPNeighborsBgpNeighborRoutesOut {
    /**
     * (bool) Whether the route is exact.
     */
    exact: boolean;
    /**
     * CIDR expression of route (IP/mask).
     */
    route: string;
}

export interface GetMetalDeviceNetwork {
    /**
     * IPv4 or IPv6 address string.
     */
    address: string;
    /**
     * Bit length of the network mask of the address.
     */
    cidr: number;
    /**
     * IP version. One of `4`, `6`.
     */
    family: number;
    /**
     * Address of router.
     */
    gateway: string;
    /**
     * Whether the address is routable from the Internet.
     */
    public: boolean;
}

export interface GetMetalDevicePort {
    /**
     * Whether this port is part of a bond in bonded network setup.
     */
    bonded: boolean;
    /**
     * ID of the port.
     */
    id: string;
    /**
     * MAC address assigned to the port.
     */
    mac: string;
    /**
     * Name of the port (e.g. `eth0`, or `bond0`).
     */
    name: string;
    /**
     * Type of the port (e.g. `NetworkPort` or `NetworkBondPort`).
     */
    type: string;
}

export interface GetMetalFacilityCapacity {
    /**
     * Device plan that must be available in selected location.
     */
    plan: string;
    /**
     * Minimun number of devices that must be available in selected location.
     * Default is `1`.
     */
    quantity?: number;
}

export interface GetMetalMetroCapacity {
    /**
     * Device plan that must be available in selected location.
     */
    plan: string;
    /**
     * Minimun number of devices that must be available in selected location.
     * Default is `1`.
     */
    quantity?: number;
}

export interface GetMetalOrganizationAddress {
    /**
     * Postal address.
     */
    address: string;
    /**
     * City name.
     */
    city: string;
    /**
     * Two letter country code (ISO 3166-1 alpha-2), e.g. US.
     */
    country: string;
    /**
     * State name.
     */
    state: string;
    /**
     * Zip Code.
     */
    zipCode: string;
}

export interface GetMetalPlansFilter {
    /**
     * If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.
     */
    all?: boolean;
    /**
     * The attribute used to filter. Filter attributes are case-sensitive
     */
    attribute: string;
    /**
     * The type of comparison to apply. One of: `in` , `re`, `substring`, `lessThan`, `lessThanOrEqual`, `greaterThan`, `greaterThanOrEqual`. Default is `in`.
     */
    matchBy?: string;
    /**
     * The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
     */
    values: string[];
}

export interface GetMetalPlansPlan {
    availableInMetros: string[];
    availableIns: string[];
    class: string;
    deploymentTypes: string[];
    description: string;
    /**
     * id of the plan
     */
    id: string;
    legacy: boolean;
    line: string;
    /**
     * name of the plan
     * - `slug`- plan slug
     * - `description`- description of the plan
     * - `line`- plan line, e.g. baremetal
     * - `legacy`- flag showing if it's a legacy plan
     * - `class`- plan class
     * - `pricingHour`- plan hourly price
     * - `pricingMonth`- plan monthly price
     * - `deploymentTypes`- list of deployment types, e.g. on_demand, spotMarket
     * - `availableIn`- list of facilities where the plan is available
     * - `availableInMetros`- list of facilities where the plan is available
     */
    name: string;
    pricingHour: number;
    pricingMonth: number;
    slug: string;
}

export interface GetMetalPlansSort {
    /**
     * The attribute used to filter. Filter attributes are case-sensitive
     */
    attribute: string;
    /**
     * Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
     */
    direction?: string;
}

export interface GetMetalProjectBgpConfig {
    /**
     * Autonomous System Number for local BGP deployment.
     */
    asn: number;
    /**
     * One of `private`, `public`.
     */
    deploymentType: string;
    /**
     * The maximum number of route filters allowed per server.
     */
    maxPrefix: number;
    /**
     * Password for BGP session in plaintext (not a checksum).
     */
    md5?: string;
    /**
     * Status of BGP configuration in the project.
     */
    status: string;
}

export interface GetNetworkDeviceClusterDetail {
    /**
     * The id of the cluster
     */
    clusterId: string;
    clusterName: string;
    node0s: outputs.GetNetworkDeviceClusterDetailNode0[];
    node1s: outputs.GetNetworkDeviceClusterDetailNode1[];
    /**
     * The number of nodes in the cluster
     */
    numOfNodes: number;
}

export interface GetNetworkDeviceClusterDetailNode0 {
    /**
     * Unique identifier of applied license file
     */
    licenseFileId: string;
    licenseToken: string;
    /**
     * Name of an existing Equinix Network Edge device
     */
    name: string;
    /**
     * UUID of an existing Equinix Network Edge device
     */
    uuid: string;
    vendorConfigurations: outputs.GetNetworkDeviceClusterDetailNode0VendorConfiguration[];
}

export interface GetNetworkDeviceClusterDetailNode0VendorConfiguration {
    activationKey: string;
    adminPassword: string;
    controller1: string;
    controllerFqdn: string;
    hostname: string;
    rootPassword: string;
}

export interface GetNetworkDeviceClusterDetailNode1 {
    /**
     * Unique identifier of applied license file
     */
    licenseFileId: string;
    licenseToken: string;
    /**
     * Name of an existing Equinix Network Edge device
     */
    name: string;
    /**
     * UUID of an existing Equinix Network Edge device
     */
    uuid: string;
    vendorConfigurations: outputs.GetNetworkDeviceClusterDetailNode1VendorConfiguration[];
}

export interface GetNetworkDeviceClusterDetailNode1VendorConfiguration {
    activationKey: string;
    adminPassword: string;
    controller1: string;
    controllerFqdn: string;
    hostname: string;
    rootPassword: string;
}

export interface GetNetworkDeviceInterface {
    assignedType: string;
    id: number;
    ipAddress: string;
    macAddress: string;
    /**
     * Name of an existing Equinix Network Edge device
     */
    name: string;
    operationalStatus: string;
    /**
     * Device provisioning status
     * * INITIALIZING
     * * PROVISIONING
     * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
     * * WAITING_FOR_PRIMARY
     * * WAITING_FOR_SECONDARY
     * * WAITING_FOR_REPLICA_CLUSTER_NODES
     * * CLUSTER_SETUP_IN_PROGRESS
     * * FAILED
     * * DEPROVISIONING
     * * DEPROVISIONED
     */
    status: string;
    type: string;
}

export interface GetNetworkDeviceSecondaryDevice {
    accountNumber: string;
    /**
     * Unique identifier of applied ACL template
     */
    aclTemplateId: string;
    additionalBandwidth: number;
    /**
     * Autonomous system number
     */
    asn: number;
    hostname: string;
    /**
     * Device location Equinix Business Exchange name
     */
    ibx: string;
    /**
     * List of device interfaces
     * * `interface.#.id` - interface identifier
     * * `interface.#.name` - interface name
     * * `interface.#.status` -  interface status (AVAILABLE, RESERVED, ASSIGNED)
     * * `interface.#.operational_status` - interface operational status (up or down)
     * * `interface.#.mac_address` - interface MAC address
     * * `interface.#.ip_address` - interface IP address
     * * `interface.#.assigned_type` - interface management type (Equinix Managed or empty)
     * * `interface.#.type` - interface type
     */
    interfaces: outputs.GetNetworkDeviceSecondaryDeviceInterface[];
    licenseFile: string;
    /**
     * Unique identifier of applied license file
     */
    licenseFileId: string;
    /**
     * Device license registration status
     * * APPLYING_LICENSE
     * * REGISTERED
     * * APPLIED
     * * WAITING_FOR_CLUSTER_SETUP
     * * REGISTRATION_FAILED
     */
    licenseStatus: string;
    licenseToken: string;
    metroCode: string;
    mgmtAclTemplateUuid: string;
    /**
     * Name of an existing Equinix Network Edge device
     */
    name: string;
    notifications: string[];
    /**
     * Device redundancy type applicable for HA devices, either
     * primary or secondary
     */
    redundancyType: string;
    /**
     * Unique identifier for a redundant device applicable for HA devices
     */
    redundantId: string;
    /**
     * Device location region
     */
    region: string;
    /**
     * IP address of SSH enabled interface on the device
     */
    sshIpAddress: string;
    /**
     * FQDN of SSH enabled interface on the device
     */
    sshIpFqdn: string;
    sshKeys: outputs.GetNetworkDeviceSecondaryDeviceSshKey[];
    /**
     * Device provisioning status
     * * INITIALIZING
     * * PROVISIONING
     * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
     * * WAITING_FOR_PRIMARY
     * * WAITING_FOR_SECONDARY
     * * WAITING_FOR_REPLICA_CLUSTER_NODES
     * * CLUSTER_SETUP_IN_PROGRESS
     * * FAILED
     * * DEPROVISIONING
     * * DEPROVISIONED
     */
    status: string;
    /**
     * UUID of an existing Equinix Network Edge device
     */
    uuid: string;
    vendorConfiguration: {[key: string]: string};
    wanInterfaceId: string;
    /**
     * Device location zone code
     */
    zoneCode: string;
}

export interface GetNetworkDeviceSecondaryDeviceInterface {
    assignedType: string;
    id: number;
    ipAddress: string;
    macAddress: string;
    /**
     * Name of an existing Equinix Network Edge device
     */
    name: string;
    operationalStatus: string;
    /**
     * Device provisioning status
     * * INITIALIZING
     * * PROVISIONING
     * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
     * * WAITING_FOR_PRIMARY
     * * WAITING_FOR_SECONDARY
     * * WAITING_FOR_REPLICA_CLUSTER_NODES
     * * CLUSTER_SETUP_IN_PROGRESS
     * * FAILED
     * * DEPROVISIONING
     * * DEPROVISIONED
     */
    status: string;
    type: string;
}

export interface GetNetworkDeviceSecondaryDeviceSshKey {
    keyName: string;
    username: string;
}

export interface GetNetworkDeviceSshKey {
    keyName: string;
    username: string;
}

export interface MetalConnectionPort {
    id: string;
    linkStatus: string;
    /**
     * Name of the connection resource
     */
    name: string;
    role: string;
    /**
     * Connection speed - one of 50Mbps, 200Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps.
     */
    speed: number;
    /**
     * Status of the connection resource.
     */
    status: string;
    virtualCircuitIds: any[];
}

export interface MetalConnectionServiceToken {
    expiresAt: string;
    id: string;
    maxAllowedSpeed: string;
    role: string;
    state: string;
    /**
     * Connection type - dedicated or shared.
     */
    type: string;
}

export interface MetalDeviceIpAddress {
    /**
     * CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
     */
    cidr?: number;
    /**
     * List of UUIDs of IP block reservations
     * from which the public IPv4 address should be taken.
     */
    reservationIds?: string[];
    /**
     * One of `privateIpv4`, `publicIpv4`, `publicIpv6`.
     */
    type: string;
}

export interface MetalDeviceNetwork {
    /**
     * IPv4 or IPv6 address string.
     */
    address: string;
    /**
     * CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
     */
    cidr: number;
    /**
     * IP version. One of `4`, `6`.
     */
    family: number;
    /**
     * Address of router.
     */
    gateway: string;
    /**
     * Whether the address is routable from the Internet.
     */
    public: boolean;
}

export interface MetalDevicePort {
    /**
     * Whether this port is part of a bond in bonded network setup.
     */
    bonded: boolean;
    /**
     * ID of the port.
     */
    id: string;
    /**
     * MAC address assigned to the port.
     */
    mac: string;
    /**
     * Name of the port (e.g. `eth0`, or `bond0`).
     */
    name: string;
    /**
     * One of `privateIpv4`, `publicIpv4`, `publicIpv6`.
     */
    type: string;
}

export interface MetalDeviceReinstall {
    /**
     * Whether the OS disk should be filled with `00h` bytes before reinstall.
     * Defaults to `false`.
     */
    deprovisionFast?: boolean;
    /**
     * Whether the provider should favour reinstall over destroy and create. Defaults to
     * `false`.
     */
    enabled?: boolean;
    /**
     * Whether the non-OS disks should be kept or wiped during reinstall.
     * Defaults to `false`.
     */
    preserveData?: boolean;
}

export interface MetalOrganizationAddress {
    /**
     * Postal address.
     */
    address: string;
    /**
     * City name.
     */
    city: string;
    /**
     * Two letter country code (ISO 3166-1 alpha-2), e.g. US.
     */
    country: string;
    /**
     * State name.
     */
    state?: string;
    /**
     * Zip Code.
     */
    zipCode: string;
}

export interface MetalProjectBgpConfig {
    /**
     * Autonomous System Number for local BGP deployment.
     */
    asn: number;
    /**
     * `private` or `public`, the `private` is likely to be usable immediately, the
     * `public` will need to be reviewed by Equinix Metal engineers.
     */
    deploymentType: string;
    /**
     * The maximum number of route filters allowed per server.
     */
    maxPrefix: number;
    /**
     * Password for BGP session in plaintext (not a checksum).
     */
    md5?: string;
    /**
     * status of BGP configuration in the project.
     */
    status: string;
}

export interface MetalSpotMarketRequestInstanceParameters {
    alwaysPxe?: boolean;
    billingCycle: string;
    customdata?: string;
    description?: string;
    features?: string[];
    hostname: string;
    ipxeScriptUrl?: string;
    /**
     * Blocks deletion of the SpotMarketRequest device until the lock is disabled.
     */
    locked?: boolean;
    operatingSystem: string;
    plan: string;
    projectSshKeys?: string[];
    tags?: string[];
    termintationTime: string;
    userSshKeys?: string[];
    userdata?: string;
}

export interface NetworkACLTemplateDeviceDetail {
    /**
     * Device ACL provisioning status where template was applied. One of `PROVISIONING`,
     * `PROVISIONED`.
     */
    aclStatus: string;
    /**
     * ACL template name.
     */
    name: string;
    /**
     * Device uuid.
     */
    uuid: string;
}

export interface NetworkACLTemplateInboundRule {
    /**
     * Inbound traffic destination ports. Allowed values are a comma separated
     * list of ports, e.g., `20,22,23`, port range, e.g., `1023-1040` or word `any`.
     */
    dstPort: string;
    /**
     * Inbound traffic protocol. One of `IP`, `TCP`, `UDP`.
     */
    protocol: string;
    sequenceNumber: number;
    /**
     * @deprecated Source Type will not be returned
     */
    sourceType: string;
    /**
     * Inbound traffic source ports. Allowed values are a comma separated list
     * of ports, e.g., `20,22,23`, port range, e.g., `1023-1040` or word `any`.
     */
    srcPort: string;
    /**
     * Inbound traffic source IP subnet in CIDR format.
     */
    subnet?: string;
    /**
     * Inbound traffic source IP subnets in CIDR format.
     *
     * @deprecated Use Subnet instead
     */
    subnets?: string[];
}

export interface NetworkDeviceClusterDetails {
    /**
     * The ID of the cluster.
     */
    clusterId: string;
    /**
     * The name of the cluster device
     */
    clusterName: string;
    /**
     * An object that has `node0` configuration.
     * See Cluster Details - Nodes below for more details.
     */
    node0: outputs.NetworkDeviceClusterDetailsNode0;
    /**
     * An object that has `node1` configuration.
     * See Cluster Details - Nodes below for more details.
     */
    node1: outputs.NetworkDeviceClusterDetailsNode1;
    /**
     * The number of nodes in the cluster.
     */
    numOfNodes: number;
}

export interface NetworkDeviceClusterDetailsNode0 {
    /**
     * License file id. This is necessary for Fortinet and Juniper clusters.
     */
    licenseFileId?: string;
    /**
     * License token. This is necessary for Palo Alto clusters.
     */
    licenseToken?: string;
    /**
     * Device name.
     */
    name: string;
    /**
     * Device unique identifier.
     */
    uuid: string;
    /**
     * An object that has fields relevant to the vendor of the
     * cluster device. See Cluster Details - Nodes - Vendor Configuration
     * below for more details.
     */
    vendorConfiguration?: outputs.NetworkDeviceClusterDetailsNode0VendorConfiguration;
}

export interface NetworkDeviceClusterDetailsNode0VendorConfiguration {
    /**
     * Activation key. This is required for Velocloud clusters.
     */
    activationKey?: string;
    /**
     * The administrative password of the device. You can use it to log in
     * to the console. This field is not available for all device types.
     */
    adminPassword: string;
    /**
     * System IP Address. Mandatory for the Fortinet SDWAN cluster device.
     */
    controller1?: string;
    /**
     * Controller fqdn. This is required for Velocloud clusters.
     */
    controllerFqdn?: string;
    /**
     * Hostname. This is necessary for Palo Alto, Juniper, and Fortinet clusters.
     */
    hostname?: string;
    /**
     * The CLI password of the device. This field is relevant only for the
     * Velocloud SDWAN cluster.
     */
    rootPassword?: string;
}

export interface NetworkDeviceClusterDetailsNode1 {
    /**
     * License file id. This is necessary for Fortinet and Juniper clusters.
     */
    licenseFileId?: string;
    /**
     * License token. This is necessary for Palo Alto clusters.
     */
    licenseToken?: string;
    /**
     * Device name.
     */
    name: string;
    /**
     * Device unique identifier.
     */
    uuid: string;
    /**
     * An object that has fields relevant to the vendor of the
     * cluster device. See Cluster Details - Nodes - Vendor Configuration
     * below for more details.
     */
    vendorConfiguration?: outputs.NetworkDeviceClusterDetailsNode1VendorConfiguration;
}

export interface NetworkDeviceClusterDetailsNode1VendorConfiguration {
    /**
     * Activation key. This is required for Velocloud clusters.
     */
    activationKey?: string;
    /**
     * The administrative password of the device. You can use it to log in
     * to the console. This field is not available for all device types.
     */
    adminPassword: string;
    /**
     * System IP Address. Mandatory for the Fortinet SDWAN cluster device.
     */
    controller1?: string;
    /**
     * Controller fqdn. This is required for Velocloud clusters.
     */
    controllerFqdn?: string;
    /**
     * Hostname. This is necessary for Palo Alto, Juniper, and Fortinet clusters.
     */
    hostname?: string;
    /**
     * The CLI password of the device. This field is relevant only for the
     * Velocloud SDWAN cluster.
     */
    rootPassword?: string;
}

export interface NetworkDeviceInterface {
    /**
     * interface management type (Equinix Managed or empty).
     */
    assignedType: string;
    /**
     * interface identifier.
     */
    id: number;
    /**
     * interface IP address.
     */
    ipAddress: string;
    /**
     * interface MAC address.
     */
    macAddress: string;
    /**
     * Device name.
     */
    name: string;
    /**
     * interface operational status. One of `up`, `down`.
     */
    operationalStatus: string;
    /**
     * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
     */
    status: string;
    /**
     * interface type.
     */
    type: string;
}

export interface NetworkDeviceLinkDevice {
    /**
     * Device ASN number. Not required for self configured devices.
     */
    asn?: number;
    /**
     * Device identifier.
     */
    id: string;
    /**
     * Device network interface identifier to use for device link
     * connection.
     */
    interfaceId?: number;
    /**
     * IP address from device link subnet that was assigned to the device
     */
    ipAddress: string;
    /**
     * device link provisioning status on a given device. One of `PROVISIONING`,
     * `PROVISIONED`, `DEPROVISIONING`, `DEPROVISIONED`, `FAILED`.
     */
    status: string;
}

export interface NetworkDeviceLinkLink {
    /**
     * billing account number to be used for
     * connection charges
     */
    accountNumber: string;
    /**
     * connection destination metro code.
     */
    dstMetroCode: string;
    /**
     * connection destination zone code is not required.
     *
     * @deprecated DestinationZoneCode is not required
     */
    dstZoneCode?: string;
    /**
     * connection source metro code.
     */
    srcMetroCode: string;
    /**
     * connection source zone code is not required.
     *
     * @deprecated SourceZoneCode is not required
     */
    srcZoneCode?: string;
    /**
     * connection throughput.
     */
    throughput: string;
    /**
     * connection throughput unit (Mbps or Gbps).
     */
    throughputUnit: string;
}

export interface NetworkDeviceSecondaryDevice {
    /**
     * Billing account number for secondary device.
     */
    accountNumber: string;
    /**
     * Identifier of a WAN interface ACL template that will be applied
     * on a secondary device.
     */
    aclTemplateId?: string;
    /**
     * Additional Internet bandwidth, in Mbps, for a secondary
     * device.
     */
    additionalBandwidth: number;
    /**
     * (Autonomous System Number) Unique identifier for a network on the internet.
     */
    asn: number;
    /**
     * Secondary device hostname.
     */
    hostname?: string;
    /**
     * Device location Equinix Business Exchange name.
     */
    ibx: string;
    /**
     * List of device interfaces. See Interface Attribute below
     * for more details.
     */
    interfaces: outputs.NetworkDeviceSecondaryDeviceInterface[];
    /**
     * Path to the license file that will be uploaded and applied on a
     * secondary device. Applicable for some devices types in BYOL licensing mode.
     */
    licenseFile?: string;
    /**
     * License file id. This is necessary for Fortinet and Juniper clusters.
     */
    licenseFileId: string;
    /**
     * Device license registration status. Possible values are `APPLYING_LICENSE`,
     * `REGISTERED`, `APPLIED`, `WAITING_FOR_CLUSTER_SETUP`, `REGISTRATION_FAILED`.
     */
    licenseStatus: string;
    /**
     * License Token can be provided for some device types o the device.
     */
    licenseToken?: string;
    /**
     * Metro location of a secondary device.
     */
    metroCode: string;
    /**
     * Identifier of an MGMT interface ACL template that will be
     * applied on the device.
     * * `ssh-key` - (Optional) Up to one definition of SSH key that will be provisioned on a secondary
     * device.
     */
    mgmtAclTemplateUuid?: string;
    /**
     * Secondary device name.
     */
    name: string;
    /**
     * List of email addresses that will receive notifications about
     * secondary device.
     */
    notifications: string[];
    /**
     * Device redundancy type applicable for HA devices, either
     * primary or secondary.
     */
    redundancyType: string;
    /**
     * Unique identifier for a redundant device applicable for HA devices.
     */
    redundantId: string;
    /**
     * Device location region.
     */
    region: string;
    /**
     * IP address of SSH enabled interface on the device.
     */
    sshIpAddress: string;
    /**
     * FQDN of SSH enabled interface on the device.
     */
    sshIpFqdn: string;
    sshKey?: outputs.NetworkDeviceSecondaryDeviceSshKey;
    /**
     * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
     */
    status: string;
    /**
     * Device unique identifier.
     */
    uuid: string;
    /**
     * Key/Value pairs of vendor specific configuration parameters
     * for a secondary device. Key values are `controller1`, `activationKey`, `managementType`, `siteId`,
     * `systemIpAddress`.
     */
    vendorConfiguration: {[key: string]: string};
    wanInterfaceId?: string;
    /**
     * Device location zone code.
     */
    zoneCode: string;
}

export interface NetworkDeviceSecondaryDeviceInterface {
    /**
     * interface management type (Equinix Managed or empty).
     */
    assignedType: string;
    /**
     * interface identifier.
     */
    id: number;
    /**
     * interface IP address.
     */
    ipAddress: string;
    /**
     * interface MAC address.
     */
    macAddress: string;
    /**
     * Device name.
     */
    name: string;
    /**
     * interface operational status. One of `up`, `down`.
     */
    operationalStatus: string;
    /**
     * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
     */
    status: string;
    /**
     * interface type.
     */
    type: string;
}

export interface NetworkDeviceSecondaryDeviceSshKey {
    keyName: string;
    /**
     * username associated with given key.
     */
    username: string;
}

export interface NetworkDeviceSshKey {
    keyName: string;
    /**
     * username associated with given key.
     */
    username: string;
}

